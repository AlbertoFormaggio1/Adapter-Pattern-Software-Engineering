<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Fri May 14 13:46:40 CEST 2021 -->
<title>KeySetValuesTester</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-05-14">
<meta name="description" content="declaration: package: myTest, class: KeySetValuesTester">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">myTest</a></div>
<h1 title="Class KeySetValuesTester" class="title">Class KeySetValuesTester</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">myTest.KeySetValuesTester</div>
</div>
<section class="description">
<hr>
<pre>public class <span class="type-name-label">KeySetValuesTester</span>
extends java.lang.Object</pre>
<div class="block">Questa suite di test ha il compito di testare tutte le funzionalita' delle classi <code>KeySet</code> e <code>ValueCollection</code>.<p>
 Il corretto comportamento degli iteratori e' testato in una suite separata. <p>
 Si vuole dimostrare che tutti i metodi definiti in <code>KeySet</code> e <code>ValueCollection</code> funzionino correttamente.</div>
<dl class="notes">
<dt>Author:</dt>
<dd>Formaggio Alberto</dd>
<dt>See Also:</dt>
<dd><a href="EntrySetAbstractCollectionTester.html" title="class in myTest"><code>EntrySetAbstractCollectionTester</code></a>, 
<a href="SetCollectionIteratorTester.html" title="class in myTest"><code>SetCollectionIteratorTester</code></a>, 
<a href="MapAdapterTester.html" title="class in myTest"><code>MapAdapterTester</code></a></dd>
<dt><b>Test Suite Design:</b></dt>
<dd>Per testare la classe nella sua interezza e' stato testato ciascun metodo fornendo in input parametri validi
 e non validi in modo da testare il piu' ampio numero di casi possibili in cui la collezione si puo' trovare.<p>
 La documentazione di ciascun test case e' stata eseguita seguendo la colonna "homework" fornita nel file della consegna,
 inoltre i metodi hanno tutti un nome che e' il piu' evocativo possibile.</dd>
<dt><b>Pre-Condition:</b></dt>
<dd>Tutti i metodi definiti nella classe <code>AbstractCollection</code> sono gia' stati testati esaustivamente nella suite
 <a href="EntrySetAbstractCollectionTester.html">EntrySetAbstractCollectionTester</a>. Tali metodi non verranno dunque testati
 nuovamente qui dal momento che sono esattamente gli stessi.</dd>
<dt><b>Post-Condition:</b></dt>
<dd>Si sono ottenuti i risultati dell'esecuzione di tutti i test in questa suite.</dd>
<dt>Test Suite Execution Records:</dt>
<dd>Consultare il file <a href="..\..\Test suite execution records\Test Results - KeySetValuesTester.html">
    "Test Results - KeySetValuesTester.html"</a> nella cartella "Test suite execution records"</dd>
<dt>Execution Variables:</dt>
<dd>I test sono stati eseguiti utilizzando JUnit v4.13 e hamcrest v1.3.
 Per poter lanciare i test e' necessario inserire i file .jar di questi framework all'interno del CLASSPATH settando tale
 variabile di ambiente.</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>private <a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#keys">keys</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>private <a href="../myAdapter/MapAdapter.html" title="class in myAdapter">MapAdapter</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#map">map</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>private <a href="../myAdapter/HCollection.html" title="interface in myAdapter">HCollection</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#values">values</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">KeySetValuesTester</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#initialize()">initialize</a></span>()</code></th>
<td class="col-last">
<div class="block">Crea un oggetto MapAdapter contenente le seguenti coppie chiave valore:</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsExceptionIfNullParam()">testContainsExceptionIfNullParam</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object contains(Object o)</code>: testa che il metodo <code>contains</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui il valore passato sia <code>null</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsFalseIfKeyIsNotInMap()">testContainsFalseIfKeyIsNotInMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>false</code>
 quando si cerca una chiave che non e' presente all'interno del set.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsFalseIfValueIsNotInMap()">testContainsFalseIfValueIsNotInMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>false</code>
 quando si cerca un valore che non e' presente all'interno del set.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsTrueIfKeyIsInMap()">testContainsTrueIfKeyIsInMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>true</code>
 quando si cerca una chiave che e' presente all'interno del set.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsTrueIfValueIsInMap()">testContainsTrueIfValueIsInMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>true</code>
 quando si cerca un valore che e' presente all'interno del set.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetEqualsDifferentKeysSameValues()">testKeySetEqualsDifferentKeysSameValues</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 keyset con lo stesso numero di elementi ma con
 almeno una chiave diversa siano diversi.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetEqualsDifferentSize()">testKeySetEqualsDifferentSize</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 keySet con un numero di elementi diversi non siano uguali.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetEqualsSameKeys()">testKeySetEqualsSameKeys</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 keyset con lo stesso numero di elementi e stesse chiavi
 siano uguali</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetHashCodeDifferentKeys()">testKeySetHashCodeDifferentKeys</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 set diversi, anche parzialmente, abbiano due codici
 hash diversi.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetHashCodeSameKeys()">testKeySetHashCodeSameKeys</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 keyset uguali abbiano lo stesso hashCode</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetRemoveBacking()">testKeySetRemoveBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando una chiave all'interno del set,
 rimuova l'entry associata anche all'interno della mappa.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetRemoveFailsSameSize()">testKeySetRemoveFailsSameSize</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la tentata rimozione di un elemento
 che non era presente all'interno del set abbia lasciato invariata la dimensione del set.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetRemoveFalseIfKeyWasNotInSet()">testKeySetRemoveFalseIfKeyWasNotInSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che non era presente
 all'interno del set venga ritornato <code>false</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetRemoveRemovesKeyFromSet()">testKeySetRemoveRemovesKeyFromSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando una chiave all'interno del set,
 rimuova effettivamente l'elemento dal set.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testKeySetRemoveTrueIfKeyWasInSet()">testKeySetRemoveTrueIfKeyWasInSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che era presente
 all'interno del set venga ritornato <code>true</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesContainsExceptionIfNullParam()">testValuesContainsExceptionIfNullParam</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object contains(Object o)</code>: testa che il metodo <code>contains</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui il valore passato sia <code>null</code>.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesEqualsDifferentSize()">testValuesEqualsDifferentSize</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 collezione di values con un numero di elementi diversi 
 non siano uguali.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesEqualsDifferentValuesSameKeys()">testValuesEqualsDifferentValuesSameKeys</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 collezioni di values con lo stesso numero di elementi ma con
 almeno un valore diverso siano diverse.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesEqualsSameValuesDuplicatesAnyKeys()">testValuesEqualsSameValuesDuplicatesAnyKeys</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 collezioni di values con gli stessi elementi, anche
 duplicati, siano uguali nonostante le chiavi siano diverse.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesHashCodeDifferentValues()">testValuesHashCodeDifferentValues</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 collection di values diverse, anche parzialmente, abbiano due codici
 hash diversi.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesHashCodeSameValues()">testValuesHashCodeSameValues</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 collezioni di values uguali abbiano lo stesso hashCode</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesRemoveBacking()">testValuesRemoveBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando un valore all'interno della collezione,
 rimuova l'entry associata anche all'interno della mappa.</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesRemoveFailsSameSize()">testValuesRemoveFailsSameSize</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la tentata rimozione di un valore
 che non era presente all'interno della collezione abbia lasciato invariata la dimensione della collezione.</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesRemoveFalseIfValueWasNotInSet()">testValuesRemoveFalseIfValueWasNotInSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che non era presente
 all'interno della collezione di values venga ritornato <code>false</code>.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesRemoveRemovesJustOneEntryBacking()">testValuesRemoveRemovesJustOneEntryBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando un valore all'interno della collezione,
 rimuova un'entry associata anche all'interno della mappa.</div>
</td>
</tr>
<tr class="alt-color" id="i26">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesRemoveRemovesValueFromSet()">testValuesRemoveRemovesValueFromSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando un valore all'interno
 della collezione, rimuova effettivamente l'elemento dalla collezione.</div>
</td>
</tr>
<tr class="row-color" id="i27">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testValuesRemoveTrueIfValueWasInSet()">testValuesRemoveTrueIfValueWasInSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che era presente
 all'interno della collezione di values venga ritornato <code>true</code>.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="map">
<h3>map</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/MapAdapter.html" title="class in myAdapter">MapAdapter</a></span>&nbsp;<span class="member-name">map</span></div>
</section>
</li>
<li>
<section class="detail" id="keys">
<h3>keys</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></span>&nbsp;<span class="member-name">keys</span></div>
</section>
</li>
<li>
<section class="detail" id="values">
<h3>values</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HCollection.html" title="interface in myAdapter">HCollection</a></span>&nbsp;<span class="member-name">values</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>KeySetValuesTester</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">KeySetValuesTester</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="initialize()">
<h3>initialize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">initialize</span>()</div>
<div class="block">Crea un oggetto MapAdapter contenente le seguenti coppie chiave valore:
 <pre>
 | 0 |  "zero" |
 | 1 |  "uno"  |
 | 2 |  "due"  |
 </pre>
 Crea poi il keySet e la values Collection contenenti tali chiavi e valori.</div>
</section>
</li>
<li>
<section class="detail" id="testKeySetRemoveTrueIfKeyWasInSet()">
<h3>testKeySetRemoveTrueIfKeyWasInSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetRemoveTrueIfKeyWasInSet</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che era presente
 all'interno del set venga ritornato <code>true</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando la chiave passata non si trova nel keySet
 Si vuole che quando l'elemento non sia presente nel set(quindi nella mappa) la rimozione non abbia successo e venga
 ritornato il corretto valore booleano.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato rimosso un elemento dal set. L'elemento e' quello passato come parametro.</dd>
<dt>Test Description:</dt>
<dd>Si rimuove un valore tra quelli che era stato precedentemente inserito all'interno del set e si testa se il metodo
 <code>remove(Object)</code> ha ritornato <code>true</code></dd>
<dt>Expected Results:</dt>
<dd><code>remove</code> deve ritornare <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetRemoveFalseIfKeyWasNotInSet()">
<h3>testKeySetRemoveFalseIfKeyWasNotInSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetRemoveFalseIfKeyWasNotInSet</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che non era presente
 all'interno del set venga ritornato <code>false</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando la chiave passata non si trova nel keySet
 Si vuole che quando l'elemento non sia presente nel set(quindi nella mappa) la rimozione non abbia successo e venga
 ritornato il corretto valore booleano.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere un valore che non era stato precedentemente inserito nel set. Siccome l'elemento non era presente
 <code>remove</code> deve ritornare <code>false</code>.</dd>
<dt>Expected Results:</dt>
<dd><code>remove</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetRemoveFailsSameSize()">
<h3>testKeySetRemoveFailsSameSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetRemoveFailsSameSize</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la tentata rimozione di un elemento
 che non era presente all'interno del set abbia lasciato invariata la dimensione del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando la chiave passata non si trova nel keySet
 Si vuole che quando l'elemento non sia presente nel set(quindi nella mappa) la rimozione non abbia successo e che quindi la dimensione sia la
 stessa (ad esempio sono sicuro che non venga rimosso un elemento a caso).</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato. La dimensione e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Dopo aver ottenuto il set di chiavi, si salva la sua dimensione prima di andare ad invocare
 il metodo remove.
 Si invoca il metodo remove passando una chiave che non e' presente all'interno del keySet</dd>
<dt>Expected Results:</dt>
<dd><code>size</code> deve ritornare la dimensione precedentemente salvata.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetRemoveRemovesKeyFromSet()">
<h3>testKeySetRemoveRemovesKeyFromSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetRemoveRemovesKeyFromSet</span>()</div>
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando una chiave all'interno del set,
 rimuova effettivamente l'elemento dal set. Dopo la rimozione l'elemento non deve essere piu' presente.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>remove</code> con rimozione dell'elemento dal set a cui apparteneva.</dd>
<dt>Pre-Condition:</dt>
<dd>keyset creato dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>La chiave passata al metodo remove e' stata rimossa dal set. La dimensione e' diminuita di 1.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere una chiave (1) che e' presente all'interno del set (e' stata inserita all'interno del set dal
 metodo initialize).
 Siccome 1 e' presente nel set, dopo la rimozione l'elemento non deve piu' essere presente. Si testa cio' usando il metodo
 contains.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsTrueIfKeyIsInMap()">
<h3>testContainsTrueIfKeyIsInMap</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsTrueIfKeyIsInMap</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>true</code>
 quando si cerca una chiave che e' presente all'interno del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>contains</code> quando la chiave passata si trova nel keyset</dd>
<dt>Pre-Condition:</dt>
<dd>keyset inizializzato dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato</dd>
<dt>Test Description:</dt>
<dd>Si cerca una chiave presente all'interno del set con il metodo <code>contains</code>. Siccome la chiave e' stata
 inserita al momento dell'inizializzazione e non e' mai stata rimossa, la chiave deve risultare presente.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> deve ritornare <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsFalseIfKeyIsNotInMap()">
<h3>testContainsFalseIfKeyIsNotInMap</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsFalseIfKeyIsNotInMap</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>false</code>
 quando si cerca una chiave che non e' presente all'interno del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>contains</code> quando la chiave passata non si trova nel keySet. Si accerta il corretto
 valore di ritorno.</dd>
<dt>Pre-Condition:</dt>
<dd>keyset inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato</dd>
<dt>Test Description:</dt>
<dd>Si cerca all'interno del keyset una chiave che non e' mai stata inserita. Siccome la chiave non e' mai stata
 inserita, bisogna che il metodo <code>contains</code> non trovi tale chiave.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsExceptionIfNullParam()">
<h3>testContainsExceptionIfNullParam</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsExceptionIfNullParam</span>()</div>
<div class="block">Test del metodo <code>public Object contains(Object o)</code>: testa che il metodo <code>contains</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui il valore passato sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>contains</code> qualora il valore non sia valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova ad ispezionare il valore nullo. Essendo null un elemento non valido per il set,
 deve essere sollevata eccezione: l'ispezione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetEqualsDifferentSize()">
<h3>testKeySetEqualsDifferentSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetEqualsDifferentSize</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 keySet con un numero di elementi diversi non siano uguali.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento del metodo <code>equals</code> per cui quando si hanno 2 keySet diversi venga ritornato
 <code>false</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Set creato dal metodo initialize(). Secondo keyset contenente una parte degli elementi della mappa originale.</dd>
<dt>Post-Condition:</dt>
<dd>Nessuno dei due set e' stato modificato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova mappa con solo una parte degli elementi della mappa originale.
 Per quanto dichiarato dalla documentazione, i due keySet ritornati dalle 2 mappe sono diversi. Il controllo viene fatto usando equals()</dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetEqualsDifferentKeysSameValues()">
<h3>testKeySetEqualsDifferentKeysSameValues</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetEqualsDifferentKeysSameValues</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 keyset con lo stesso numero di elementi ma con
 almeno una chiave diversa siano diversi.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento del metodo <code>equals</code> per cui quando si hanno 2 keySet diversi venga ritornato
 <code>false</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Set creato dal metodo initialize(). Secondo keyset contenente un numero di elementi pari alla mappa originale ma chiavi diverse.</dd>
<dt>Post-Condition:</dt>
<dd>Nessuno dei due set e' stato modificato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova mappa con 2 entries uguali a quelle della mappa originale e una che differisce
 per la chiave.
 Per quanto dichiarato dalla documentazione, i due keySet ritornati dalle 2 mappe sono diversi in quanto almeno una chiave e' diversa.
 Il controllo viene fatto usando equals()</dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetEqualsSameKeys()">
<h3>testKeySetEqualsSameKeys</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetEqualsSameKeys</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 keyset con lo stesso numero di elementi e stesse chiavi
 siano uguali</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento del metodo <code>equals</code> per cui quando si hanno 2 keySet uguali venga ritornato
 <code>true</code>. Il risultato non deve dipendere dal campo Value relativo all'entry a cui la chiave appartiene. Ovvero, anche se i valori sono
 diversi ma le chiavi sono le stesse, equals deve avere successo.</dd>
<dt>Pre-Condition:</dt>
<dd>Set creato dal metodo initialize(). Secondo keyset contenente un numero di elementi pari alla mappa originale con le stesse chiavi.</dd>
<dt>Post-Condition:</dt>
<dd>Nessuno dei due set e' stato modificato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova mappa dove tutti le entries hanno la stessa chiave della mappa originale.
 Per quanto dichiarato dalla documentazione, i due keySet ritornati dalle 2 mappe sono uguali in quanto tutte le chiavi sono uguali.
 Il controllo viene fatto con <code>equals</code></dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetHashCodeSameKeys()">
<h3>testKeySetHashCodeSameKeys</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetHashCodeSameKeys</span>()</div>
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 keyset uguali abbiano lo stesso hashCode</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>due keyset uguali hanno lo stesso codice hash.</dd>
<dt>Pre-Condition:</dt>
<dd>2 keyset opportunamente creati uguali tra loro secondo i parametri definiti da equals (stesse chiavi nelle entries).</dd>
<dt>Post-Condition:</dt>
<dd>i set sono rimasti invariati.</dd>
<dt>Test Description:</dt>
<dd>Creazione di un nuovo oggetto MapAdapter. Ad entrambe le mappe esistenti, aggiungo le stesse chiavi inserite dal
 metodo initialize(). Dalle due mappe ottengo i keySet e ne calcolo l'hashCode</dd>
<dt>Expected Results:</dt>
<dd>I due keyset hanno lo stesso hashCode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetHashCodeDifferentKeys()">
<h3>testKeySetHashCodeDifferentKeys</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetHashCodeDifferentKeys</span>()</div>
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 set diversi, anche parzialmente, abbiano due codici
 hash diversi.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>due set diversi hanno codici hash diversi. Si testa inserendo nel set elementi comuni e non</dd>
<dt>Pre-Condition:</dt>
<dd>2 set con chiavi almeno in parte diverse per quanto definito da equals.</dd>
<dt>Post-Condition:</dt>
<dd>i set sono rimasti invariati</dd>
<dt>Test Description:</dt>
<dd>Creazione di un nuovo oggetto MapAdapter. Ad entrambe le mappe esistenti, aggiungo le stesse chiavi inserite dal metodo
 initialize ma almeno una chiave diversa. I due set devono avere codici hash diversi in quanto differiscono per almeno una chiave.</dd>
<dt>Expected Results:</dt>
<dd>i due keyset NON hanno lo stesso hashCode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testKeySetRemoveBacking()">
<h3>testKeySetRemoveBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testKeySetRemoveBacking</span>()</div>
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando una chiave all'interno del set,
 rimuova l'entry associata anche all'interno della mappa.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento di backing di <code>remove</code> con rimozione dell'elemento dalla mappa a cui apparteneva.</dd>
<dt>Pre-Condition:</dt>
<dd>keyset creato dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>L'entry associata alla chiave passata al metodo remove e' stata rimossa dalla mappa.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere una chiave che e' presente all'interno del keyset. La rimozione deve rimuovere l'entry anche dalla
 mappa. Si verifica cie' usando il metodo <code>contains</code></dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsTrueIfValueIsInMap()">
<h3>testContainsTrueIfValueIsInMap</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsTrueIfValueIsInMap</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>true</code>
 quando si cerca un valore che e' presente all'interno del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>contains</code> quando il valore passato si trova nella collezione di values.
 Si accerta il corretto valore di ritorno.</dd>
<dt>Pre-Condition:</dt>
<dd>collezione di values inizializzata dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>La collezione e' rimasta invariata</dd>
<dt>Test Description:</dt>
<dd>Si cerca un valore presente all'interno della collezione con il metodo <code>contains</code>. Siccome il valore e' stato
 inserita al momento dell'inizializzazione e non e' mai stato rimosso, il valore deve risultare presente.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> deve ritornare <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsFalseIfValueIsNotInMap()">
<h3>testContainsFalseIfValueIsNotInMap</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsFalseIfValueIsNotInMap</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>false</code>
 quando si cerca un valore che non e' presente all'interno del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>contains</code> il valore passato si trova nella collezione di values.
 Si accerta il corretto valore di ritorno.</dd>
<dt>Pre-Condition:</dt>
<dd>collezione di values inizializzata dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>La collezione e' rimasta invariata</dd>
<dt>Test Description:</dt>
<dd>Si cerca un valore all'interno della collezione che non e' mai stato inserito. Siccome il valore non e' mai stato
 inserito, bisogna che il metodo <code>contains</code> non trovi tale valore.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesContainsExceptionIfNullParam()">
<h3>testValuesContainsExceptionIfNullParam</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesContainsExceptionIfNullParam</span>()</div>
<div class="block">Test del metodo <code>public Object contains(Object o)</code>: testa che il metodo <code>contains</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui il valore passato sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>contains</code> qualora il valore non sia valido.</dd>
<dt>Pre-Condition:</dt>
<dd>collezione di values inizializzata dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>La collezione e' rimasta invariata</dd>
<dt>Test Description:</dt>
<dd>Si prova ad ispezionare il valore nullo. Essendo null un elemento non valido per la collezione,
 deve essere sollevata eccezione: l'ispezione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesRemoveTrueIfValueWasInSet()">
<h3>testValuesRemoveTrueIfValueWasInSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesRemoveTrueIfValueWasInSet</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che era presente
 all'interno della collezione di values venga ritornato <code>true</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando il valore passato non si trova nella collezione.
 Si vuole che quando l'elemento non sia presente nella collezione(quindi nella mappa) la rimozione non abbia successo e venga
 ritornato il corretto valore booleano.</dd>
<dt>Pre-Condition:</dt>
<dd>Collezione inizializzata dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato rimosso un elemento dalla collezione. L'elemento e' quello passato come parametro.</dd>
<dt>Test Description:</dt>
<dd>Si rimuove un valore tra quelli che era stato precedentemente inserito all'interno della collezione e si testa se il metodo
 <code>remove(Object)</code> ha ritornato <code>true</code></dd>
<dt>Expected Results:</dt>
<dd><code>remove</code> deve ritornare <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesRemoveFalseIfValueWasNotInSet()">
<h3>testValuesRemoveFalseIfValueWasNotInSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesRemoveFalseIfValueWasNotInSet</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che non era presente
 all'interno della collezione di values venga ritornato <code>false</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando il valore passato non si trova nella collezione di valori.
 Si vuole che quando l'elemento non sia presente nella collezione (quindi nemmeno nella mappa) la rimozione non abbia successo e venga
 ritornato il corretto valore booleano.</dd>
<dt>Pre-Condition:</dt>
<dd>Collezione di values inizializzata dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La collezione e' rimasta invariata</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere un valore che non era stato precedentemente inserito nella collezione. Siccome l'elemento
 non era presente <code>remove</code> deve ritornare <code>false</code>.</dd>
<dt>Expected Results:</dt>
<dd><code>remove</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesRemoveFailsSameSize()">
<h3>testValuesRemoveFailsSameSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesRemoveFailsSameSize</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la tentata rimozione di un valore
 che non era presente all'interno della collezione abbia lasciato invariata la dimensione della collezione.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando la chiave passata non si trova nella collezione di values
 Si vuole che quando l'elemento non sia presente nella collezione(quindi nella mappa) la rimozione non abbia successo e che quindi
 la dimensione sia la stessa (ad esempio sono sicuro che non venga rimosso un elemento a caso).</dd>
<dt>Pre-Condition:</dt>
<dd>Collezione di values inizializzata dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La collezione e' rimasta invariata. La dimensione e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Dopo aver ottenuto la collection di values, si salva la sua dimensione prima di andare ad invocare
 il metodo remove.
 Si invoca il metodo remove passando un valore che non e' presente all'interno della collezione.</dd>
<dt>Expected Results:</dt>
<dd><code>size</code> deve ritornare la dimensione precedentemente salvata.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesRemoveRemovesValueFromSet()">
<h3>testValuesRemoveRemovesValueFromSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesRemoveRemovesValueFromSet</span>()</div>
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando un valore all'interno
 della collezione, rimuova effettivamente l'elemento dalla collezione. Dopo la rimozione l'elemento non deve essere piu' presente.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>remove</code> con rimozione dell'elemento dalla collezione a cui apparteneva.</dd>
<dt>Pre-Condition:</dt>
<dd>Collection di values creata dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>Il valore passato al metodo remove e' stato rimosso dalla collection. La dimensione e' diminuita di 1.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere un valore ("uno") che e' presente all'interno della collezione (e' stato inserita all'interno
 della collezione dal metodo initialize).
 Siccome "uno" e' presente nel set, dopo la rimozione l'elemento non deve piu' essere presente. Si testa cio' usando il metodo
 contains.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesEqualsSameValuesDuplicatesAnyKeys()">
<h3>testValuesEqualsSameValuesDuplicatesAnyKeys</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesEqualsSameValuesDuplicatesAnyKeys</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 collezioni di values con gli stessi elementi, anche
 duplicati, siano uguali nonostante le chiavi siano diverse. L'uguaglianza deve dipendere solo dai valori.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento del metodo <code>equals</code> per cui quando si hanno 2 collezioni di values uguali venga ritornato
 <code>true</code>. Il risultato non deve dipendere dal campo Key relativo all'entry a cui il valore appartiene. Ovvero, anche se le chiavi sono
 diverse ma i valori sono gli stessi, equals deve avere successo.</dd>
<dt>Pre-Condition:</dt>
<dd>Collezioni create dal metodo initialize() con l'aggiunta di duplicati.
 Seconda collezione contenente un numero di elementi pari alla mappa originale con gli stessi valori ma chiavi diverse.</dd>
<dt>Post-Condition:</dt>
<dd>Nessuna delle due collezioni e' stata modificata.</dd>
<dt>Test Description:</dt>
<dd>Si inseriscono dei duplicati di valori per avere un caso generale.
 Si crea una nuova mappa dove tutte le entries hanno gli stessi valori della mappa originale ma chiavi diverse (0,5,10,15,20).
 Per quanto dichiarato dalla documentazione, le 2 collezioni ritornate dalle 2 mappe sono uguali in quanto tutti i valori sono uguali.
 Il controllo viene fatto con <code>equals</code></dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesEqualsDifferentSize()">
<h3>testValuesEqualsDifferentSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesEqualsDifferentSize</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 collezione di values con un numero di elementi diversi 
 non siano uguali.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento del metodo <code>equals</code> per cui quando si hanno 2 collezioni di valori diversi venga ritornato
 <code>false</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Collezione di values creata dal metodo initialize(). Seconda collezione contenente solo una parte degli elementi della mappa originale.</dd>
<dt>Post-Condition:</dt>
<dd>Nessuna delle due collezioni e' stata modificata.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova mappa con solo una parte degli elementi della mappa originale.
 Per quanto dichiarato dalla documentazione, le due collection di values ritornate dalle 2 mappe sono diverse.
 Il controllo viene fatto usando equals()</dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesEqualsDifferentValuesSameKeys()">
<h3>testValuesEqualsDifferentValuesSameKeys</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesEqualsDifferentValuesSameKeys</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 collezioni di values con lo stesso numero di elementi ma con
 almeno un valore diverso siano diverse.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento del metodo <code>equals</code> per cui quando si hanno 2 collezioni di values diverse venga ritornato
 <code>false</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Collezione di values creato dal metodo initialize(). Secondo keyset contenente un numero di elementi pari alla mappa originale ma chiavi diverse.</dd>
<dt>Post-Condition:</dt>
<dd>Nessuna delle due collezioni e' stata modificata.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova mappa con 2 entries uguali a quelle della mappa originale e una che differisce
 per il valore.
 Per quanto dichiarato dalla documentazione, le due collection ritornate dalle 2 mappe sono diverse in quanto almeno un valore e' diverso.
 Il controllo viene fatto usando equals()</dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesHashCodeSameValues()">
<h3>testValuesHashCodeSameValues</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesHashCodeSameValues</span>()</div>
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 collezioni di values uguali abbiano lo stesso hashCode</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>due collezioni di values uguali hanno lo stesso codice hash.</dd>
<dt>Pre-Condition:</dt>
<dd>2 collezioni di values opportunamente create uguali tra loro secondo i parametri definiti da equals
 (stessi valori nelle entries).</dd>
<dt>Post-Condition:</dt>
<dd>i set sono rimasti invariati.</dd>
<dt>Test Description:</dt>
<dd>Creazione di un nuovo oggetto MapAdapter. Ad entrambe le mappe esistenti, aggiungo gli stessi valori inseriti dal
 metodo initialize(). Dalle due mappe ottengo le collezioni di values e ne calcolo l'hashCode</dd>
<dt>Expected Results:</dt>
<dd>Le due collezioni hanno lo stesso hashCode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesHashCodeDifferentValues()">
<h3>testValuesHashCodeDifferentValues</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesHashCodeDifferentValues</span>()</div>
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 collection di values diverse, anche parzialmente, abbiano due codici
 hash diversi.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>due collezioni diverse hanno codici hash diversi. Si testa inserendo nella collection elementi comuni e non</dd>
<dt>Pre-Condition:</dt>
<dd>2 collection di values con valori almeno in parte diverse per quanto definito da equals.</dd>
<dt>Post-Condition:</dt>
<dd>le due collection sono rimaste invariate.</dd>
<dt>Test Description:</dt>
<dd>Creazione di un nuovo oggetto MapAdapter. Ad entrambe le mappe esistenti, aggiungo le stesse chiavi inserite dal metodo
 initialize ma almeno un valore diverso. Le due collezioni devono avere codici hash diversi in quanto differiscono per almeno un valore.</dd>
<dt>Expected Results:</dt>
<dd>Le due collezioni NON hanno lo stesso hashcode</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesRemoveBacking()">
<h3>testValuesRemoveBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesRemoveBacking</span>()</div>
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando un valore all'interno della collezione,
 rimuova l'entry associata anche all'interno della mappa.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento di backing di <code>remove</code> con rimozione dell'elemento dalla mappa a cui apparteneva.
 <b>ATTENZIONE</b>: Si fa notare che, non essendo specificato dalla documentazione, la collezione ritornata <b>NON</b> e' un set, quindi
 in questo caso ammette duplicati. Non essendo un set, quando si rimuove un valore viene rimossa solo un'entry a caso tra quelle
 che hanno come valore il valore passato come parametro.</dd>
<dt>Pre-Condition:</dt>
<dd>Collection di values creata dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>Un'entry associata al valore passata al metodo remove e' stata rimossa dalla mappa. La dimensione della mappa e' diminuita di 1.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere un valore che e' presente all'interno della collezione. La rimozione deve rimuovere un'entry
 con tale valore anche dalla mappa. Si verifica cio' usando il metodo <code>contains</code></dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testValuesRemoveRemovesJustOneEntryBacking()">
<h3>testValuesRemoveRemovesJustOneEntryBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testValuesRemoveRemovesJustOneEntryBacking</span>()</div>
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando un valore all'interno della collezione,
 rimuova un'entry associata anche all'interno della mappa.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento di backing di <code>remove</code> con rimozione dell'elemento dalla mappa a cui apparteneva.
 <b>ATTENZIONE</b>: Si fa notare che, non essendo specificato dalla documentazione, la collezione ritornata <b>NON</b> e' un set, quindi
 in questo caso ammette duplicati. Non essendo un set, quando si rimuove un valore viene rimossa solo un'entry a caso tra quelle
 che hanno come valore il valore passato come parametro.</dd>
<dt>Pre-Condition:</dt>
<dd>Collection di values creata dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>Un'entry associata al valore passata al metodo remove e' stata rimossa dalla mappa.</dd>
<dt>Test Description:</dt>
<dd>Si inseriscono dei duplicati di un certo valore all'interno della mappa associati a chiavi diverse.
 Si prova a rimuovere un valore che e' presente all'interno della collezione. La rimozione deve rimuovere soltanto un'entry
 con tale valore anche dalla mappa. Si verifica cio' usando il metodo size</dd>
<dt>Expected Results:</dt>
<dd><code>size</code> ritorna la dimensione precedente alla rimozione -1.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
