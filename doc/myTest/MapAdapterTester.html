<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Fri May 14 13:46:40 CEST 2021 -->
<title>MapAdapterTester</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-05-14">
<meta name="description" content="declaration: package: myTest, class: MapAdapterTester">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">myTest</a></div>
<h1 title="Class MapAdapterTester" class="title">Class MapAdapterTester</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">myTest.MapAdapterTester</div>
</div>
<section class="description">
<hr>
<pre>public class <span class="type-name-label">MapAdapterTester</span>
extends java.lang.Object</pre>
<div class="block">Questa suite di test ha il compito di testare tutte le funzionalita' base della classe <code>MapAdapter</code>. <p> Il corretto comportamento
 delle classi che sono strettamente correlate a questa (ovvero <code>EntrySet, KeySet, ValueCollection</code>) sono testate in una
 suite separata.<p>
 Si vuole dimostrare che tutti i metodi definiti in MapAdapter funzionino correttamente</div>
<dl class="notes">
<dt>Author:</dt>
<dd>Formaggio Alberto</dd>
<dt>See Also:</dt>
<dd><a href="EntrySetAbstractCollectionTester.html" title="class in myTest"><code>EntrySetAbstractCollectionTester</code></a>, 
<a href="KeySetValuesTester.html" title="class in myTest"><code>KeySetValuesTester</code></a>, 
<a href="EntryTester.html" title="class in myTest"><code>EntryTester</code></a></dd>
<dt><b>Test Suite Design:</b></dt>
<dd>Per testare la classe nella sua interezza e' stato testato ciascun metodo fornendo in input parametri validi
 e non validi in modo da testare il piu' ampio numero di casi possibili in cui la collezione si puo' trovare.<p>
 La documentazione di ciascun test case e' stata eseguita seguendo la colonna "homework" fornita nel file della consegna,
 inoltre i metodi hanno tutti un nome che e' il piu' evocativo possibile.</dd>
<dt><b>Pre-Condition:</b></dt>
<dd>Si assicura che i metodi della classe Hashtable di Java J2ME CLDC 1.1 siano gia' stati esaustivamente testati
 al rilascio di Java J2ME CLDC 1.1. Per tale motivo i metodi qui di seguito elencati non verranno testati in quanto semplici
 metodi wrapper che richiamano un metodo della classe Hashtable definita in CLDC 1.1 (con le stesse eccezioni definite in
 Java J2SE 1.4.2 e le stesse funzionalita'):
 <ul>
     <li>size</li>
     <li>isEmpty</li>
     <li>containsValue</li>
     <li>put</li>
     <li>clear</li>
 </ul></dd>
<dt><b>Post-Condition:</b></dt>
<dd>Si sono ottenuti i risultati dell'esecuzione di tutti i test in questa suite.</dd>
<dt>Test Suite Execution Records:</dt>
<dd>Consultare il file <a href="..\..\Test suite execution records\Test Results - MapAdapterTester.html">
     "Test Results - MapAdapterTester.html"</a> nella cartella "Test suite execution records"</dd>
<dt>Execution Variables:</dt>
<dd>I test sono stati eseguiti utilizzando JUnit v4.13 e hamcrest v1.3.
 Per poter lanciare i test e' necessario inserire i file .jar di questi framework all'interno del CLASSPATH settando tale
 variabile di ambiente.</dd>
<dt>Note aggiuntive:</dt>
<dd>Si fa notare che non e' presente il test dell'eccezione ArrayStoreException del metodo toArray(Object[]) in quanto gestito
 da Java a tempo di runtime.</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>private <a href="../myAdapter/MapAdapter.html" title="class in myAdapter">MapAdapter</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#map">map</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">MapAdapterTester</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#initialize()">initialize</a></span>()</code></th>
<td class="col-last">
<div class="block">Crea un oggetto MapAdapter contenente le seguenti coppie chiave valore:</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingEntrySetClear()">testBackingEntrySetClear</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void clear()</code>: testa che il metodo <code>clear</code> invocato sull'oggetto MapAdapter rimuova tutti
 gli elementi da un keySet creato prima dell'invocazione del metodo.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingEntrySetPut()">testBackingEntrySetPut</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object put(Object key, Object value)</code>: testa che il metodo <code>put</code> aggiunga gli elementi
 in un entrySet creato prima dell'inserimento.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingEntrySetRemove()">testBackingEntrySetRemove</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object remove()</code>: testa che il metodo <code>remove</code> invocato sull'oggetto MapAdapter rimuova l'entry associata
 alla chiave passata anche da un entrySet creato prima dell'invocazione del metodo.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingKeySetClear()">testBackingKeySetClear</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void clear()</code>: testa che il metodo <code>clear</code> invocato sull'oggetto MapAdapter rimuova tutti
 gli elementi da un keySet creato prima dell'invocazione del metodo.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingKeySetPut()">testBackingKeySetPut</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object put(Object key, Object value)</code>: testa che il metodo <code>put</code> aggiunga gli elementi
 in un keySet creato prima dell'inserimento.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingKeySetRemove()">testBackingKeySetRemove</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object remove()</code>: testa che il metodo <code>remove</code> invocato sull'oggetto MapAdapter rimuova la chiave passata
 anche da un keySet creato prima dell'invocazione del metodo.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingValuesClear()">testBackingValuesClear</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void clear()</code>: testa che il metodo <code>clear</code> invocato sull'oggetto MapAdapter rimuova tutti
 gli elementi da una collezione di values creata prima dell'invocazione del metodo.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingValuesPut()">testBackingValuesPut</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object put(Object key, Object value)</code>: testa che il metodo <code>put</code> aggiunga gli elementi
 in una collection di values creata prima dell'inserimento.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testBackingValuesRemove()">testBackingValuesRemove</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object remove()</code>: testa che il metodo <code>remove</code> invocato sull'oggetto MapAdapter rimuova il valore
 associato alla chiave passata anche da una collezione contenete i valori della mappa creata prima dell'invocazione del metodo.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsKeyExceptionIfKeyIsNull()">testContainsKeyExceptionIfKeyIsNull</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object add(Object key)</code>: testa che il metodo <code>add</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la chiave passata sia <code>null</code>.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testGetExceptionIfKeyIsNull()">testGetExceptionIfKeyIsNull</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object get(Object key)</code>: testa che il metodo <code>get</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la chiave passata sia <code>null</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPutAllExceptionIfMapIsNull()">testPutAllExceptionIfMapIsNull</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object putAll(HMap t)</code>: testa che il metodo <code>putAll</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la mappa passata sia <code>null</code>.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPutAllInsertsAllElementInGivenMap()">testPutAllInsertsAllElementInGivenMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean putAll(HMap t)</code>: testa che il metodo <code>putAll</code> aggiunga gli elementi
 nella mappa passata all'interno della mappa corrente.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveExceptionIfKeyIsNull()">testRemoveExceptionIfKeyIsNull</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object remove(Object key)</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la chiave passata sia <code>null</code>.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="map">
<h3>map</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/MapAdapter.html" title="class in myAdapter">MapAdapter</a></span>&nbsp;<span class="member-name">map</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>MapAdapterTester</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">MapAdapterTester</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="initialize()">
<h3>initialize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">initialize</span>()</div>
<div class="block">Crea un oggetto MapAdapter contenente le seguenti coppie chiave valore:
 <pre>
 | 0 |  "zero" |
 | 1 |  "uno"  |
 | 2 |  "due"  |
 | 3 |  "tre"  |
 | 4 |"quattro"|
 </pre></div>
</section>
</li>
<li>
<section class="detail" id="testContainsKeyExceptionIfKeyIsNull()">
<h3>testContainsKeyExceptionIfKeyIsNull</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsKeyExceptionIfKeyIsNull</span>()</div>
<div class="block">Test del metodo <code>public Object add(Object key)</code>: testa che il metodo <code>add</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la chiave passata sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>add</code> qualora la chiave non sia valida.</dd>
<dt>Pre-Condition:</dt>
<dd>Mappa inizializzata con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Si prova ad interrogare la manda chiedendo se la chiave nulla e' presente. Essendo null un elemento non valido per la mappa,
 deve essere sollevata eccezione: l'ispezione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testGetExceptionIfKeyIsNull()">
<h3>testGetExceptionIfKeyIsNull</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testGetExceptionIfKeyIsNull</span>()</div>
<div class="block">Test del metodo <code>public Object get(Object key)</code>: testa che il metodo <code>get</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la chiave passata sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>get</code> qualora la chiave non sia valida.</dd>
<dt>Pre-Condition:</dt>
<dd>Mappa inizializzata con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Si prova ad ottenere il valore associato alla chiave nulla. Essendo null un elemento non valido per la mappa,
 deve essere sollevata eccezione: l'ispezione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveExceptionIfKeyIsNull()">
<h3>testRemoveExceptionIfKeyIsNull</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveExceptionIfKeyIsNull</span>()</div>
<div class="block">Test del metodo <code>public Object remove(Object key)</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la chiave passata sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>remove</code> qualora la chiave non sia valida.</dd>
<dt>Pre-Condition:</dt>
<dd>Mappa inizializzata con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere il valore associato alla chiave nulla. Essendo null un elemento non valido per la mappa,
 deve essere sollevata eccezione: la rimozione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPutAllExceptionIfMapIsNull()">
<h3>testPutAllExceptionIfMapIsNull</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPutAllExceptionIfMapIsNull</span>()</div>
<div class="block">Test del metodo <code>public Object putAll(HMap t)</code>: testa che il metodo <code>putAll</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la mappa passata sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>putAll</code> qualora la mappa passata non sia valida.</dd>
<dt>Pre-Condition:</dt>
<dd>Mappa inizializzata con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Si prova ad inserire nella mappa una mappa HMap che pero' non fa riferimento ad alcuna collezione.
 L'operazione deve fallire perche' <code>null</code> non e' una mappa valida.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPutAllInsertsAllElementInGivenMap()">
<h3>testPutAllInsertsAllElementInGivenMap</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPutAllInsertsAllElementInGivenMap</span>()</div>
<div class="block">Test del metodo <code>public boolean putAll(HMap t)</code>: testa che il metodo <code>putAll</code> aggiunga gli elementi
 nella mappa passata all'interno della mappa corrente.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>putAll</code> quando viene fornita una mappa valida in input</dd>
<dt>Pre-Condition:</dt>
<dd>La mappa e' stata inizializzata da intialize()</dd>
<dt>Post-Condition:</dt>
<dd>Gli elementi sono stati aggiunti alla lista. La dimensione della lista e' aumentata di 3.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo mapAdapter in cui si inseriscono delle entry che prima non erano presenti all'interno della mappa
 in cui si va a fare l'inserimento.
 Si inseriscono gli elementi e si verifica con il metodo <code>containsAll</code> di entrySet che la mappa contenga tutti gli elementi della mappa
 passata</dd>
<dt>Expected Results:</dt>
<dd><code>containsAll</code> deve ritornare <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingEntrySetPut()">
<h3>testBackingEntrySetPut</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingEntrySetPut</span>()</div>
<div class="block">Test del metodo <code>public Object put(Object key, Object value)</code>: testa che il metodo <code>put</code> aggiunga gli elementi
 in un entrySet creato prima dell'inserimento.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing dell'EntrySet: quando si inserisce un elemento nella mappa, l'inserimento
 deve avvenire pure nell'EntrySet ritornato in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La coppia e' stata inserita sia nella mappa che nell'entrySet.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene l'entrySet associato ad una mappa e in seguito si effettua l'inserimento in tale mappa.
 Si crea in seguito una seconda mappa che ha il solo scopo di inserire la stessa coppia chiave-valore e di ritornare l'entry dall'entrySet
 (in questo caso l'entrySet e' stato creato dopo l'inserimento, per cui l'entry e' sicuramente presente).
 Si testa quindi se tale entry e' presente all'interno dell'entrySet relativo alla mappa originale mediante il metodo <code>contains</code></dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingKeySetPut()">
<h3>testBackingKeySetPut</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingKeySetPut</span>()</div>
<div class="block">Test del metodo <code>public Object put(Object key, Object value)</code>: testa che il metodo <code>put</code> aggiunga gli elementi
 in un keySet creato prima dell'inserimento.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing del KeySet: quando si inserisce un elemento nella mappa, l'inserimento
 deve avvenire pure nel keySet ritornato in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>keySet di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La coppia e' stata inserita sia nella mappa. La chiave di tale coppia e' stata inserita nel keySet.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene il keyset associato ad una mappa e in seguito si effettua l'inserimento in tale mappa.
 Si testa quindi se la chiave della coppia inserita e' presente all'interno del keySet relativo alla mappa mediante il metodo <code>contains</code></dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingValuesPut()">
<h3>testBackingValuesPut</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingValuesPut</span>()</div>
<div class="block">Test del metodo <code>public Object put(Object key, Object value)</code>: testa che il metodo <code>put</code> aggiunga gli elementi
 in una collection di values creata prima dell'inserimento.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing della collezione di values: quando si inserisce un elemento nella mappa, l'inserimento
 deve avvenire pure nella collezione ritornata in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>Collezione di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La coppia e' stata inserita sia nella mappa. Il valore di tale coppia e' stato inserito nella collezione.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene la collezione di valori associata ad una mappa e in seguito si effettua l'inserimento in tale mappa.
 Si testa quindi se il valore della coppia inserita e' presente all'interno della collezione relativa alla mappa mediante il metodo <code>contains</code></dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingEntrySetClear()">
<h3>testBackingEntrySetClear</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingEntrySetClear</span>()</div>
<div class="block">Test del metodo <code>public void clear()</code>: testa che il metodo <code>clear</code> invocato sull'oggetto MapAdapter rimuova tutti
 gli elementi da un keySet creato prima dell'invocazione del metodo.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing del KeySet: quando si svuota un oggetto MapAdapter, deve essere svuotato
 pure il keySet ritornato in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>keySet di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e il keySet sono stati svuotati.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene il keyset associato ad una mappa e in seguito si effettua la cancellazione di tutti gli elementi
 nella mappa invocando il metodo clear. Ora la mappa e' vuota e pure il set deve esserlo.
 Si testa quindi che il set ritornato in precedenza sia vuoto usando il metodo <code>isEmpty</code></dd>
<dt>Expected Results:</dt>
<dd><code>isEmpty</code> ritorna <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingKeySetClear()">
<h3>testBackingKeySetClear</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingKeySetClear</span>()</div>
<div class="block">Test del metodo <code>public void clear()</code>: testa che il metodo <code>clear</code> invocato sull'oggetto MapAdapter rimuova tutti
 gli elementi da un keySet creato prima dell'invocazione del metodo.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing del KeySet: quando si svuota un oggetto MapAdapter, deve essere svuotato
 pure il keySet ritornato in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>keySet di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e il keySet sono stati svuotati.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene il keyset associato ad una mappa e in seguito si effettua la cancellazione di tutti gli elementi
 nella mappa invocando il metodo clear. Ora la mappa e' vuota e pure il set deve esserlo.
 Si testa quindi che il set ritornato in precedenza sia vuoto usando il metodo <code>isEmpty</code></dd>
<dt>Expected Results:</dt>
<dd><code>isEmpty</code> ritorna <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingValuesClear()">
<h3>testBackingValuesClear</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingValuesClear</span>()</div>
<div class="block">Test del metodo <code>public void clear()</code>: testa che il metodo <code>clear</code> invocato sull'oggetto MapAdapter rimuova tutti
 gli elementi da una collezione di values creata prima dell'invocazione del metodo.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing della collezione di values: quando si svuota un oggetto MapAdapter, deve essere svuotata
 pure la collezione ritornata in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>keySet di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e la collezione sono state svuotate.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene la collezione di values associata ad una mappa e in seguito si effettua la cancellazione di tutti gli elementi
 nella mappa invocando il metodo clear. Ora la mappa e' vuota e pure la collezione deve esserlo.
 Si testa quindi che la collezizone ritornata in precedenza sia vuota usando il metodo <code>isEmpty</code></dd>
<dt>Expected Results:</dt>
<dd><code>isEmpty</code> ritorna <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingEntrySetRemove()">
<h3>testBackingEntrySetRemove</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingEntrySetRemove</span>()</div>
<div class="block">Test del metodo <code>public Object remove()</code>: testa che il metodo <code>remove</code> invocato sull'oggetto MapAdapter rimuova l'entry associata
 alla chiave passata anche da un entrySet creato prima dell'invocazione del metodo.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing dell'entrySet: quando si rimuove una coppia da un oggetto MapAdapter, deve essere rimossa
 la relativa entry pure dall'entrySet ritornato in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>entryset di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e l'entryset hanno un elemento in meno.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene l'entrySet associato ad una mappa e in seguito si effettua la rimozione della coppia di chiave 0 dall'oggetto
 MapAdapter invocando il metodo <code>remove</code> (coppia che e' (0,"zero")). Ora la mappa non contiene piu' la coppia associata alla chiave 0
 (e quindi anche l'entrySet). Si testa quindi che il set ritornato in precedenza non contenga tale entry usando il metodo <code>contains</code></dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingKeySetRemove()">
<h3>testBackingKeySetRemove</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingKeySetRemove</span>()</div>
<div class="block">Test del metodo <code>public Object remove()</code>: testa che il metodo <code>remove</code> invocato sull'oggetto MapAdapter rimuova la chiave passata
 anche da un keySet creato prima dell'invocazione del metodo.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing del KeySet: quando si rimuove una coppia da un oggetto MapAdapter, deve essere rimossa
 la relativa chiave pure dal keySet ritornato in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>keySet di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e il keySet hanno un elemento in meno.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene il keyset associato ad una mappa e in seguito si effettua la rimozione della coppia di chiave 0 dall'oggetto
 MapAdapter invocando il metodo <code>remove</code>. La mappa non contiene piu' la chiave 0 (e quindi nemmeno il keySet).
 Si testa quindi che il set ritornato in precedenza non contenga tale chiave usando il metodo <code>contains</code></dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testBackingValuesRemove()">
<h3>testBackingValuesRemove</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testBackingValuesRemove</span>()</div>
<div class="block">Test del metodo <code>public Object remove()</code>: testa che il metodo <code>remove</code> invocato sull'oggetto MapAdapter rimuova il valore
 associato alla chiave passata anche da una collezione contenete i valori della mappa creata prima dell'invocazione del metodo.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento delle funzionalita' di backing della collection di values: quando si rimuove una coppia da un oggetto MapAdapter,
 deve essere rimossa il relativo valore pure dalla collection ritornata in precedenza.</dd>
<dt>Pre-Condition:</dt>
<dd>collection di supporto alla mappa ottenuto prima dell'inserimento.</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e la collezione hanno un elemento in meno.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene la collezione di valori associato ad una mappa e in seguito si effettua la rimozione della coppia di chiave 0
 dall'oggetto MapAdapter invocando il metodo <code>remove</code>. Ora la mappa non contiene piu' la coppia associata alla chiave 0, quindi pure il valore
 ad essa associato ("zero") non deve piu' essere presente nella collezione.
 Si testa quindi che il set ritornato in precedenza non contenga tale valore usando il metodo <code>contains</code></dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
