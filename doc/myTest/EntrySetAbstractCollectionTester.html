<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Fri May 14 13:46:40 CEST 2021 -->
<title>EntrySetAbstractCollectionTester</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-05-14">
<meta name="description" content="declaration: package: myTest, class: EntrySetAbstractCollectionTester">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">myTest</a></div>
<h1 title="Class EntrySetAbstractCollectionTester" class="title">Class EntrySetAbstractCollectionTester</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">myTest.EntrySetAbstractCollectionTester</div>
</div>
<section class="description">
<hr>
<pre>public class <span class="type-name-label">EntrySetAbstractCollectionTester</span>
extends java.lang.Object</pre>
<div class="block">Questa suite di test ha il compito di testare tutte le funzionalita' base della classe <code>AbstractCollection</code> e
 <code>EntrySet</code>.<p>
 Dal momento che <code>AbstractCollection</code> e', come dice il nome stesso, una classe astratta, non e' possibile testare
 direttamente le funzionalita' definite al suo interno ma e' necessario testare una classe concreta che la estende.
 Si e' deciso dunque di utilizzare a questo scopo la classe <code>EntrySet</code>.<p>
 <p> Il corretto comportamento dell'iteratore della classe <code>EntrySet</code> e' testato in una suite separata. <p>
 Si vuole dimostrare che tutti i metodi definiti in EntrySet e AbastractCollection funzionino correttamente.</div>
<dl class="notes">
<dt>Author:</dt>
<dd>Formaggio Alberto</dd>
<dt>See Also:</dt>
<dd><a href="EntryTester.html" title="class in myTest"><code>EntryTester</code></a>, 
<a href="KeySetValuesTester.html" title="class in myTest"><code>KeySetValuesTester</code></a>, 
<a href="SetCollectionIteratorTester.html" title="class in myTest"><code>SetCollectionIteratorTester</code></a>, 
<a href="MapAdapterTester.html" title="class in myTest"><code>MapAdapterTester</code></a></dd>
<dt><b>Test Suite Design:</b></dt>
<dd>Per testare la classe nella sua interezza e' stato testato ciascun metodo fornendo in input parametri validi
 e non validi in modo da testare il piu' ampio numero di casi possibili in cui la collezione si puo' trovare.<p>
 <b>ATTENZIONE!!</b>
 Qui verranno testati una volta per tutte <b>tutti</b> i metodi definiti in <code>AbstractCollection</code>. Non ha senso
 effettuare test anche in tutte le altri classi che la estendono in quanto il corretto funzionamento dei metodi definiti
 in essa dipende solo dal corretto funzionamento degli iteratori e dei metodi <code>remove</code> e <code>contains</code>. Tali funzionalita'
 verranno invece testate esaustivamente:
    <ul>
        <li>in un'altra suite per quanto riguarda <code>ValueCollection e KeySet</code></li>
        <li>in questa suite per quanto riguarda <code>EntrySet</code>).</li>
    </ul><p>
 La documentazione di ciascun test case e' stata eseguita seguendo la colonna "homework" fornita nel file della consegna,
 inoltre i metodi hanno tutti un nome che e' il piu' evocativo possibile.</dd>
<dt><b>Pre-Condition:</b></dt>
<dd>Si assicura che i metodi qui di seguito indicati siano gia' stati testati esaustivamente dal tester della classe
 MapAdapter:
 <ul>
     <li>size</li>
     <li>isEmpty</li>
 </ul>
 <p>Dal momento che in <code>AbstractCollection</code> sono semplicemente dei metodi wrapper che utilizzano funzionalita'
 della classe <code>MapAdapter</code>, tali metodi non verranno dunque testati in questa suite.</dd>
<dt><b>Post-Condition:</b></dt>
<dd>Si sono ottenuti i risultati dell'esecuzione di tutti i test in questa suite.</dd>
<dt>Test Suite Execution Records:</dt>
<dd>Consultare il file <a href="..\..\Test suite execution records\Test Results - EntrySetAbstractCollectionTester.html">
    "Test Results - EntrySetAbstractCollectionTester.html"</a> nella cartella "Test suite execution records"</dd>
<dt>Execution Variables:</dt>
<dd>I test sono stati eseguiti utilizzando JUnit v4.13 e hamcrest v1.3.
 Per poter lanciare i test e' necessario inserire i file .jar di questi framework all'interno del CLASSPATH settando tale
 variabile di ambiente.</dd>
<dt>Note aggiuntive:</dt>
<dd>Non si controlla che l'entrySet possa contenere degli elementi nulli (o chiavi/valori non validi) in quanto l'unico modo per ottenere
 un'entry e' attraverso l'entrySet il quale, facendo riferimento alla classe MapAdapter, non puo' contenere ne' elementi ne' chiavi nulle.</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>private <a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#entrySet">entrySet</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>private <a href="../myAdapter/MapAdapter.html" title="class in myAdapter">MapAdapter</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#map">map</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">EntrySetAbstractCollectionTester</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>private boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#arrayEqualsAnyOrder(java.lang.Object%5B%5D,java.lang.Object%5B%5D,java.lang.Object%5B%5D,int)">arrayEqualsAnyOrder</a></span>&#8203;(java.lang.Object[]&nbsp;keys,
java.lang.Object[]&nbsp;values,
java.lang.Object[]&nbsp;entries,
int&nbsp;invalidElementsInEntries)</code></th>
<td class="col-last">
<div class="block">Controlla che due array siano uguali in qualsiasi ordine.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>private <a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getSetEntriesKeyInMapButDifferentValue()">getSetEntriesKeyInMapButDifferentValue</a></span>()</code></th>
<td class="col-last">
<div class="block">Ritorna un entrySet con delle Entry che non sono presenti nell'oggetto MapAdapter usato per sviluppare i test.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>private <a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getSetEntriesNeitherKeyNorValueInMap()">getSetEntriesNeitherKeyNorValueInMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Ritorna un entrySet con delle Entry che non sono presenti nell'oggetto MapAdapter usato per sviluppare i test.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>private <a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getSetEntriesNotInMap()">getSetEntriesNotInMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Ritorna un entrySet con delle Entry che non sono presenti nell'oggetto MapAdapter usato per sviluppare i test.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>private <a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getSetMixedEntries()">getSetMixedEntries</a></span>()</code></th>
<td class="col-last">
<div class="block">Ritorna un entrySet con alcune Entry presenti all'interno dell'oggetto MapAdapter usato per effettuare i test e altre
 che invece non sono presenti.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>private <a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#getSetSomeEntriesInMap()">getSetSomeEntriesInMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Ritorna un entrySet con alcune Entry presenti all'interno dell'oggetto MapAdapter usato per effettuare i test.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#initialize()">initialize</a></span>()</code></th>
<td class="col-last">
<div class="block">Crea un oggetto MapAdapter contenente le seguenti coppie chiave valore:</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddExceptionNotSupported()">testAddExceptionNotSupported</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object add(Object o)</code>: testa che il metodo <code>add</code> lanci eccezione
 <code>UnsupportedOperationException</code> nel caso in cui si provi ad invocarlo.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testClearBacking()">testClearBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void clear()</code>: testo che facendo il clear sull'entrySet, nella mappa siano stati
 cancellati tutti gli elementi.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsAllBothEmpty()">testContainsAllBothEmpty</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo il caso limite in cui sia la collezione che il set siano
 vuoti.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsAllEmptyCollection()">testContainsAllEmptyCollection</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo il caso limite in cui, nel caso in cui il set contenga degli
 elementi, la collezione vuota (cioe' con nessun elemento) sia contenuta all'interno del set.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsAllEmptySet()">testContainsAllEmptySet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo il caso limite in cui, nel caso in cui il set sia vuoto,
 una collezione con degli elementi validi al suo interno NON sia contenuta nel set.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsAllExceptionNullCollection()">testContainsAllExceptionNullCollection</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object containsAll(HCollection coll)</code>: testa che il metodo <code>containsAll</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la collezione passata sia <code>null</code>.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsAllFails()">testContainsAllFails</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo che, una volta inizializzato il set con degli elementi al suo interno,
 elementi che NON siano stati precedentemente inseriti NON siano presenti all'interno del set.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsAllSucceeds()">testContainsAllSucceeds</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo che, una volta inizializzato il set con delle entries al suo interno,
 le entries precedentemente inserite siano presenti all'interno del set utilizzando il metodo containsAll().</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsExceptionIfNotEntry()">testContainsExceptionIfNotEntry</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object contains(Object o)</code>: testa che il metodo <code>contains</code> lanci eccezione
 <code>ClassCastException</code> nel caso in cui il valore passato non sia una Entry.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsExceptionIfNullParam()">testContainsExceptionIfNullParam</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object contains(Object o)</code>: testa che il metodo <code>contains</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui il valore passato sia <code>null</code>.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsFalseIfKeyIsInMapButValueIsNot()">testContainsFalseIfKeyIsInMapButValueIsNot</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>false</code>
 quando si cerca un'entry che non e' presente all'interno del set.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsReturnsFalseIfBothKeyAndValueNotInSet()">testContainsReturnsFalseIfBothKeyAndValueNotInSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains (Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>false</code>
 quando si cerca un'entry che non e' presente all'interno del set.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsTrueIfEntryIsInMap()">testContainsTrueIfEntryIsInMap</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>true</code>
 quando si cerca un'entry che e' presente all'interno del set.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testEntrySetValueBacking()">testEntrySetValueBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object setValue(Object o)</code>: Testo che se un valore viene modificato usando il metodo <code>setValue</code>
 definito nella classe Entry, questo venga modificato anche nella mappa che contiene tale entry.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testEqualsDifferentEntries()">testEqualsDifferentEntries</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 entryset con lo stesso numero di elementi ma con
 almeno un'entry diversa siano diversi.</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testEqualsDifferentSize()">testEqualsDifferentSize</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 entryset con un numero di elementi diversi non siano uguali.</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testEqualsFailIsNull()">testEqualsFailIsNull</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che se l'argomento passato e' <code>null</code> il metodo
 ritorni false.</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testEqualsSameEntries()">testEqualsSameEntries</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 entrySet con gli stessi elementi
 siano uguali usando il metodo <code>equals</code>.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testHashCodeDifferentSets()">testHashCodeDifferentSets</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 set diversi, anche parzialmente, abbiano due codici
 hash diversi.</div>
</td>
</tr>
<tr class="alt-color" id="i26">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testHashCodeSameSets()">testHashCodeSameSets</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 entrySet uguali abbiano lo stesso hashCode</div>
</td>
</tr>
<tr class="row-color" id="i27">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveAllBackingWhenElementsAreRemoved()">testRemoveAllBackingWhenElementsAreRemoved</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean removeAll(Object o)</code>: Testo che l'invocazione di <code>removeAll</code> passando un entrySet contenente
 alcune entries che sono presenti all'interno della mappa, rimuova tali entries dalla mappa stessa.</div>
</td>
</tr>
<tr class="alt-color" id="i28">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveAllExceptionIfCollectionIsNull()">testRemoveAllExceptionIfCollectionIsNull</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object removeAll(HCollection coll)</code>: testa che il metodo <code>removeAll</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la collezione passata sia <code>null</code>.</div>
</td>
</tr>
<tr class="row-color" id="i29">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveAllMixedElements()">testRemoveAllMixedElements</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean removeAll(HCollection coll)</code>: testo che il metodo <code>removeAll</code> rimuova
 tutti gli elementi presenti all'interno della collezione dal set.</div>
</td>
</tr>
<tr class="alt-color" id="i30">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveAllRemovesAllElements()">testRemoveAllRemovesAllElements</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean removeAll(HCollection coll)</code>: testo che il metodo <code>removeAll</code> rimuova
 tutti gli elementi presenti all'interno della collezione dal set.</div>
</td>
</tr>
<tr class="row-color" id="i31">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveAllReturnsFalseIfFails()">testRemoveAllReturnsFalseIfFails</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean removeAll(HCollection c)</code>: testa che il metodo <code>removeAll</code>
 ritorni <code>false</code> nel caso in cui la collezione che si vuole rimuovere dalil set non abbia nessun elemento elemento in
 comune con il set stessa (quindi il set non viene modificata).</div>
</td>
</tr>
<tr class="alt-color" id="i32">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveAllReturnsTrueIfSucceeds()">testRemoveAllReturnsTrueIfSucceeds</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean removeAll(HCollection c)</code>: testa che il metodo <code>removeAll</code>
 ritorni <code>true</code> nel caso in cui la rimozione abbia avuto successo e abbia modificato il set.</div>
</td>
</tr>
<tr class="row-color" id="i33">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveExceptionIfEntryIsNull()">testRemoveExceptionIfEntryIsNull</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object remove(Object o)</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui il valore passato sia <code>null</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i34">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveFailsSameSizeBacking()">testRemoveFailsSameSizeBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la tentata rimozione di un elemento
 che non era presente all'interno del set abbia lasciato invariata la dimensione del set.</div>
</td>
</tr>
<tr class="row-color" id="i35">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveRemovesEntryFromMapBacking()">testRemoveRemovesEntryFromMapBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando una entry all'interno del set,
 rimuova l'elemento dalla mappa oltre che dal set.</div>
</td>
</tr>
<tr class="alt-color" id="i36">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveRemovesEntryFromSet()">testRemoveRemovesEntryFromSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando una entry all'interno del set,
 rimuova effettivamente l'elemento dal set.</div>
</td>
</tr>
<tr class="row-color" id="i37">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveReturnsFalseIfBothKeyAndValueNotInSet()">testRemoveReturnsFalseIfBothKeyAndValueNotInSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che non era presente
 all'interno del set venga ritornato <code>false</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i38">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveReturnsFalseIfKeyIsInSetButValueIsNot()">testRemoveReturnsFalseIfKeyIsInSetButValueIsNot</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di una entry che non era presente
 all'interno del set venga ritornato <code>false</code>.</div>
</td>
</tr>
<tr class="row-color" id="i39">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveReturnsTrueIfEntryWasInSet()">testRemoveReturnsTrueIfEntryWasInSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di una entry
 che era presente all'interno dell'entrySet venga ritornato <code>true</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i40">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveThrowsExceptionIfNotEntry()">testRemoveThrowsExceptionIfNotEntry</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object remove(Object o)</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>ClassCastException</code> nel caso in cui il valore passato non sia una Entry.</div>
</td>
</tr>
<tr class="row-color" id="i41">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRetainAllBackingWhenElementsAreRemoved()">testRetainAllBackingWhenElementsAreRemoved</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void boolean retainAll(Object o)</code>: Testo che l'invocazione di <code>retainAll</code> passando un entrySet contenente
 alcune entries che sono presenti all'interno della mappa, rimuova le entries non presenti nel set dalla mappa.</div>
</td>
</tr>
<tr class="alt-color" id="i42">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRetainAllDoesNotModifySet()">testRetainAllDoesNotModifySet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean retainAll(HCollection c)</code>: testa che il metodo <code>retainAll</code>
 non modifichi il set nel caso in cui tutti gli elementi siano in comune tra set e collezione.</div>
</td>
</tr>
<tr class="row-color" id="i43">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRetainAllExceptionIfCollectionIsNull()">testRetainAllExceptionIfCollectionIsNull</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object retainAll(HCollection coll)</code>: testa che il metodo <code>retainAll</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la collezione passata sia <code>null</code>.</div>
</td>
</tr>
<tr class="alt-color" id="i44">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRetainAllReturnsFalseIfSetNotChanged()">testRetainAllReturnsFalseIfSetNotChanged</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean retainAll(HCollection c)</code>: testa che il metodo <code>retainAll</code>
 ritorni <code>false</code> nel caso in cui la collezione che si vuole mantenere nel set abbia tutti gli elementi in
 comune con il set originale (quindi il set non viene modificato).</div>
</td>
</tr>
<tr class="row-color" id="i45">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRetainAllReturnsTrueIfChanged()">testRetainAllReturnsTrueIfChanged</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean retainAll(HCollection c)</code>: testa che il metodo <code>retainAll</code>
 ritorni <code>true</code> nel caso in cui la rimozione abbia avuto successo e abbia modificato il set.</div>
</td>
</tr>
<tr class="alt-color" id="i46">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRetainAllSucceeds()">testRetainAllSucceeds</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean retainAll(HCollection c)</code>: testa che il metodo <code>retainAll</code>
 lasci 2 elementi all'interno del set quando tra il set e la collezione sono presenti 2 elementi in comune.</div>
</td>
</tr>
<tr class="row-color" id="i47">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToArrayEmptySet()">testToArrayEmptySet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object[] toArray()</code>: Testo che, una volta svuotato il set, il metodo toArray() ritorni un array
 con nessun elemento al suo interno, ovvero un array vuoto di dimensione 0.</div>
</td>
</tr>
<tr class="alt-color" id="i48">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToArrayGivenArrayNewInstance()">testToArrayGivenArrayNewInstance</a></span>()</code></th>
<td class="col-last">
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array che non abbia abbastanza posti, non ritorni l'array precedentemente fornito
 bensi' una nuova istanza di <code>Object[]</code>.</div>
</td>
</tr>
<tr class="row-color" id="i49">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToArrayGivenArrayNewInstanceCorrectness()">testToArrayGivenArrayNewInstanceCorrectness</a></span>()</code></th>
<td class="col-last">
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array che non abbia abbastanza posti, si ottiene un nuovo
 array che gli elementi che devono essere esattamente quelli del set e nello stesso ordine.</div>
</td>
</tr>
<tr class="alt-color" id="i50">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToArrayGivenArrayNullAfterElements()">testToArrayGivenArrayNullAfterElements</a></span>()</code></th>
<td class="col-last">
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array con abbastanza posti, ritorni l'array precedentemente fornito
 aggiungendo <code>null</code> nei posti inutilizzati.</div>
</td>
</tr>
<tr class="row-color" id="i51">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToArrayGivenArraySameInstance()">testToArrayGivenArraySameInstance</a></span>()</code></th>
<td class="col-last">
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array con abbastanza posti, ritorni l'array precedentemente fornito
 senza creare una nuova istanza.</div>
</td>
</tr>
<tr class="alt-color" id="i52">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToArrayGivenArraySameInstanceCorrectness()">testToArrayGivenArraySameInstanceCorrectness</a></span>()</code></th>
<td class="col-last">
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array con abbastanza posti, si ottiene l'array precedentemente fornito
 con che gli elementi che devono essere esattamente quelli del set e nello stesso ordine.</div>
</td>
</tr>
<tr class="row-color" id="i53">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testToArraySafeChanges()">testToArraySafeChanges</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object[] toArray()</code>: Testo che anche se l'array ritornato viene modificato, le modifiche non hanno nessuna ripercussione sull'array originale.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="entrySet">
<h3>entrySet</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></span>&nbsp;<span class="member-name">entrySet</span></div>
</section>
</li>
<li>
<section class="detail" id="map">
<h3>map</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/MapAdapter.html" title="class in myAdapter">MapAdapter</a></span>&nbsp;<span class="member-name">map</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>EntrySetAbstractCollectionTester</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">EntrySetAbstractCollectionTester</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="initialize()">
<h3>initialize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">initialize</span>()</div>
<div class="block">Crea un oggetto MapAdapter contenente le seguenti coppie chiave valore:
 <pre>
 | 0 |  "zero" |
 | 1 |  "uno"  |
 | 2 |  "due"  |
 </pre>
 Crea poi l'entrySet contenente tali entries.</div>
</section>
</li>
<li>
<section class="detail" id="testContainsAllSucceeds()">
<h3>testContainsAllSucceeds</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsAllSucceeds</span>()</div>
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo che, una volta inizializzato il set con delle entries al suo interno,
 le entries precedentemente inserite siano presenti all'interno del set utilizzando il metodo containsAll().</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che determinati oggetti siano presenti all'interno del set una volta inseriti.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize(). La collection contiene alcune entries dell'entrySet</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si crea un entrySet con il metodo <code>getSomeEntriesInMap()</code> che contiene alcune entries che sono all'interno
 dell'entrySet. Gli elementi erano stati precedentemente inseriti dal metodo initialize(), quindi sono sicuramente presenti.
 Si invoca quindi il metodo <code>containsAll</code> passando come parametro la collezione appena creata.</dd>
<dt>Expected Results:</dt>
<dd><code>containsAll(coll)</code> ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsAllFails()">
<h3>testContainsAllFails</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsAllFails</span>()</div>
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo che, una volta inizializzato il set con degli elementi al suo interno,
 elementi che NON siano stati precedentemente inseriti NON siano presenti all'interno del set.
 Il metodo <code>containsAll()</code> non deve trovare l'elemento.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che determinati oggetti non siano presenti all'interno del set se non inseriti.
 Si prende il caso generale in cui la collezione contiene sia elementi presenti nel set che non.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzatp dal metodo initialize(). La collezione in input contiene elementi misti tra presenti nel set e non presenti.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione coll di tipo HCollection richiamando il metodo <code>getSetMixedEntries</code> che ritorna alcune
 entries all'interno del set e altre non presenti (in particolare, 2 presenti nel set e 4 non presenti).
 Si invoca quindi il metodo <code>containsAll</code> passando come parametro la collezione appena creata.</dd>
<dt>Expected Results:</dt>
<dd><code>containsAll(coll)</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsAllExceptionNullCollection()">
<h3>testContainsAllExceptionNullCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsAllExceptionNullCollection</span>()</div>
<div class="block">Test del metodo <code>public Object containsAll(HCollection coll)</code>: testa che il metodo <code>containsAll</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la collezione passata sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>containAll</code> qualora la collezione passata non sia valida.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize(). La HCollection fa riferimento a null</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova a controllare che il set contenga una HCollection coll che pero' non fa riferimento ad alcuna collezione.
 L'operazione deve fallire perche' <code>null</code> non e' una collezione valida.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsAllEmptyCollection()">
<h3>testContainsAllEmptyCollection</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsAllEmptyCollection</span>()</div>
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo il caso limite in cui, nel caso in cui il set contenga degli
 elementi, la collezione vuota (cioe' con nessun elemento) sia contenuta all'interno del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo funzioni anche nel caso limite di collezione vuota e non lanci eccezioni.
 Si ricorda che il metodo containsAll ritorna <code>false</code> nel caso in cui almeno 1 elemento della collezione non e' presente nel set,
 siccome la collezione non ha elementi, il metodo deve ritornare <code>true</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize(). Collezione in input svuotata.</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione coll di tipo HCollection che viene svuotata subito dopo l'inizializzazione per essere
 sicuri che non contenga elementi.
 Si invoca quindi il metodo <code>containsAll</code> passando come parametro la collezione appena creata.</dd>
<dt>Expected Results:</dt>
<dd><code>containsAll(coll)</code> ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsAllEmptySet()">
<h3>testContainsAllEmptySet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsAllEmptySet</span>()</div>
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo il caso limite in cui, nel caso in cui il set sia vuoto,
 una collezione con degli elementi validi al suo interno NON sia contenuta nel set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo funzioni anche nel caso limite di set vuoto e non lanci eccezioni.
 Si ricorda che il metodo containsAll ritorna <code>false</code> nel caso in cui almeno 1 elemento della collezione non e' presente nel set,
 siccome il set non ha elementi, il metodo deve ritornare <code>false</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Set svuotato contenente zero elementi.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Creo una collezione coll di tipo HCollection che viene riempita usando il metodo createColleciton(). Svuoto poi
 il set in modo che questo non contenga elementi.
 Si invoca quindi il metodo <code>containsAll</code> passando come parametro la collezione appena creata. il set non contiene
 elementi per cui non puo' nemmeno contenere la collezione passata.</dd>
<dt>Expected Results:</dt>
<dd><code>containsAll(coll)</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsAllBothEmpty()">
<h3>testContainsAllBothEmpty</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsAllBothEmpty</span>()</div>
<div class="block">Test del metodo <code>public boolean containsAll(HCollection c)</code>: Testo il caso limite in cui sia la collezione che il set siano
 vuoti.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo funzioni anche nel caso limite di collezione e set vuoto e non lanci eccezioni.
 Siccome sia il set che la collezione non contengono elementi, non ci sono elementi della collezione che non son presenti nel set
 originale, per cui <code>containsAll</code> deve ritornare <code>false</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize(). Entryset contiene zero elementi, HCollection contiene zero elementi.</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasta invariato.</dd>
<dt>Test Description:</dt>
<dd>Creo una collezione coll di tipo HCollection che viene subito svuotata. Svuoto poi il set in modo che questo
 non contenga elementi.
 Si invoca quindi il metodo <code>containsAll</code> passando come parametro la collezione appena creata. Il set non contiene
 elementi e nemmeno la collezione per cui il set contiene la collezione.</dd>
<dt>Expected Results:</dt>
<dd><code>containsAll(coll)</code> ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllRemovesAllElements()">
<h3>testRemoveAllRemovesAllElements</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveAllRemovesAllElements</span>()</div>
<div class="block">Test del metodo <code>public boolean removeAll(HCollection coll)</code>: testo che il metodo <code>removeAll</code> rimuova
 tutti gli elementi presenti all'interno della collezione dal set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Testo che la rimozione degli elementi da una collezione rimuova correttamente tutti gli elementi all'interno dell'entrySet.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize(). Collection coll correttamente inizializzata all'entrySet della mappa da cui
 andare a rimuovere gli elementi.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' vuoto.</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione con gli stessi elementi inseriti all'interno del set dal metodo initialize(). Per farlo
 si richiama nuovamento il metodo entrySet di mapAdapter.
 Siccome la collezione contiene tutti gli elementi del set, removeAll deve lasciare il set vuoto, si testa
 richiamando il metodo <code>size()</code></dd>
<dt>Expected Results:</dt>
<dd><code>size()</code> deve ritornare 0.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllReturnsTrueIfSucceeds()">
<h3>testRemoveAllReturnsTrueIfSucceeds</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveAllReturnsTrueIfSucceeds</span>()</div>
<div class="block">Test del metodo <code>public boolean removeAll(HCollection c)</code>: testa che il metodo <code>removeAll</code>
 ritorni <code>true</code> nel caso in cui la rimozione abbia avuto successo e abbia modificato il set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto valore di ritorno
 Dal momento che si richiama l'operazione <code>remove</code> per la rimozione del singolo elemento, si assicura che la dimensione del set
 venga modificata correttamente anche senza controllarlo.</dd>
<dt>Pre-Condition:</dt>
<dd>il set e' stata inizializzato da intialize(). La collezione in input contiene alcune entries dell'entryset</dd>
<dt>Post-Condition:</dt>
<dd>Gli elementi sono stati aggiunti alil set. La dimensione del set e' diminuita di 2.</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione e si inseriscono al suo interno degli elementi presenti all'interno del set
 (1,2). Si rimuovono poi gli elementi dalil set.
 Siccome la collezione non e' vuota, deve aver rimosso gli elementi dalil set, questa deve risultare modificata.</dd>
<dt>Expected Results:</dt>
<dd><code>list.removeAll(coll)</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllReturnsFalseIfFails()">
<h3>testRemoveAllReturnsFalseIfFails</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveAllReturnsFalseIfFails</span>()</div>
<div class="block">Test del metodo <code>public boolean removeAll(HCollection c)</code>: testa che il metodo <code>removeAll</code>
 ritorni <code>false</code> nel caso in cui la collezione che si vuole rimuovere dalil set non abbia nessun elemento elemento in
 comune con il set stessa (quindi il set non viene modificata).</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto valore di ritorno
 Dal momento che si richiama l'operazione <code>remove</code> per la rimozione del singolo elemento, si assicura che la dimensione del set
 venga modificata correttamente anche senza controllarlo.</dd>
<dt>Pre-Condition:</dt>
<dd>il set e' stata inizializzata da intialize(). La collezione in input contiene alcune entries NON presenti all'interno della mappa.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasta invariato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione contenete alcune entries non presenti all'interno della mappa richiamando il metodo
 <code>getSetEntriesNotInMap</code>. Si rimuovono poi gli elementi dal set.
 Siccome la collezione non contiene elementi in comune con il set, non sono stati rimossi elementi dal set e quindi
 il set non e' stata modificato.</dd>
<dt>Expected Results:</dt>
<dd><code>removeAll(coll)</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllMixedElements()">
<h3>testRemoveAllMixedElements</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveAllMixedElements</span>()</div>
<div class="block">Test del metodo <code>public boolean removeAll(HCollection coll)</code>: testo che il metodo <code>removeAll</code> rimuova
 tutti gli elementi presenti all'interno della collezione dal set. Verranno rimossi solo gli elementi che sono presenti sia
 nella collezione che nel set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Testo che la rimozione degli elementi da una collezione rimuova correttamente tutti gli elementi anche nel caso
 in cui la collezione contenga elementi non presenti all'interno del set.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize(). Collection coll correttamente inizializzata con entries miste.</dd>
<dt>Post-Condition:</dt>
<dd>il set non contiene piu le entries all'interno della collection fornita in input.</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione contenete entries miste (ovvero un po' presenti nel set e un po' no) richiamando il
 metodo <code>getSetMixedEntries</code>. Si rimuovono poi gli elementi dal set.
 Siccome la collezione contiene solo 2 elementi in comune con il set, removeAll deve rimuovere le entries (0,"zero) e (2,"due").
 Si testa che dopo la rimozione gli elementi rimossi non siano piu' presenti nel set usando il metodo <code>contains</code>.

 (NOTA: Non si usa containsAll perche' ritorna false anche nel caso in cui solo 1 elemento dei due non sia stato rimosso, io voglio testare
 che entrambi non siano presenti).</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllExceptionIfCollectionIsNull()">
<h3>testRemoveAllExceptionIfCollectionIsNull</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveAllExceptionIfCollectionIsNull</span>()</div>
<div class="block">Test del metodo <code>public Object removeAll(HCollection coll)</code>: testa che il metodo <code>removeAll</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la collezione passata sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>containAll</code> qualora la collezione passata non sia valida.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize(). HCollection che fa riferimento a null</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere una collezione HCollection coll che pero' non fa riferimento ad alcuna collezione.
 L'operazione deve fallire perche' <code>null</code> non e' una collezione valida.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRetainAllReturnsTrueIfChanged()">
<h3>testRetainAllReturnsTrueIfChanged</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRetainAllReturnsTrueIfChanged</span>()</div>
<div class="block">Test del metodo <code>public boolean retainAll(HCollection c)</code>: testa che il metodo <code>retainAll</code>
 ritorni <code>true</code> nel caso in cui la rimozione abbia avuto successo e abbia modificato il set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto valore di ritorno</dd>
<dt>Pre-Condition:</dt>
<dd>il set e' stato inizializzato da intialize(). Collezione correttamente inizializzata con entries miste.</dd>
<dt>Post-Condition:</dt>
<dd>Gli elementi sono stati rimossi dal set. La dimensione del set e' 2 (numero di elementi in comune tra la collezione e
 il set).</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione contenete entries miste (ovvero un po' presenti nel set e un po' no) richiamando il
 metodo <code>getSetMixedEntries</code>. Le entries in comune sono (0,"zero") e (2,"due") ==> saranno mantenute.
 Si rimuovono poi gli elementi dal set mantenendo solo le due entries sopra citate.
 Siccome la collezione non e' vuota, deve aver rimosso gli elementi dal set, questa deve risultare modificata.</dd>
<dt>Expected Results:</dt>
<dd><code>list.retainAll(coll)</code> deve ritornare <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRetainAllSucceeds()">
<h3>testRetainAllSucceeds</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRetainAllSucceeds</span>()</div>
<div class="block">Test del metodo <code>public boolean retainAll(HCollection c)</code>: testa che il metodo <code>retainAll</code>
 lasci 2 elementi all'interno del set quando tra il set e la collezione sono presenti 2 elementi in comune.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento del metodo <code>retainAll</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>il set e' stato inizializzato da intialize(). Collezione inizializzata con solo entries che sono presenti
 all'interno della mappa.</dd>
<dt>Post-Condition:</dt>
<dd>Son stati rimossi tutti gli elementi ad eccezione delle entries in comune (ovvero (0,"zero") e (2,"due")).</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione contenete soltanto entries presenti nella mappa usando il metodo <code>getSetSomeEntriesInMap</code>.
 Si rimuovono poi gli elementi dal set invocando retainAll.
 Siccome la collezione contiene 2 elementi in comune con la collezione passata, la dimensione finale deve essere pari a 2.</dd>
<dt>Expected Results:</dt>
<dd><code>entrySet.size</code> ritorna la stessa dimensione della collezione fornita in input.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRetainAllDoesNotModifySet()">
<h3>testRetainAllDoesNotModifySet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRetainAllDoesNotModifySet</span>()</div>
<div class="block">Test del metodo <code>public boolean retainAll(HCollection c)</code>: testa che il metodo <code>retainAll</code>
 non modifichi il set nel caso in cui tutti gli elementi siano in comune tra set e collezione.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento del metodo.</dd>
<dt>Pre-Condition:</dt>
<dd>il set e' stato inizializzato da intialize(). La collezione contiene le stesse entries del set.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione inserendo tutti gli elementi inseriti all'interno del set da parte
 del metodo initialize(). Si mantengono nel set solo gli elementi presenti all'interno della collezione.
 Siccome la collezione coincide con il set, non sono stati rimossi elementi dal set e quindi
 il set non e' stato modificato. Si controlla cio' verificando che la dimensione del set (ottenuta con size()) rimanga invariata.</dd>
<dt>Expected Results:</dt>
<dd>La dimensione del set e' 3. (pari a quella prima della chiamata al metodo)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRetainAllReturnsFalseIfSetNotChanged()">
<h3>testRetainAllReturnsFalseIfSetNotChanged</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRetainAllReturnsFalseIfSetNotChanged</span>()</div>
<div class="block">Test del metodo <code>public boolean retainAll(HCollection c)</code>: testa che il metodo <code>retainAll</code>
 ritorni <code>false</code> nel caso in cui la collezione che si vuole mantenere nel set abbia tutti gli elementi in
 comune con il set originale (quindi il set non viene modificato).</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto valore di ritorno
 Dal momento che si richiama l'operazione <code>remove</code> per l'inserimento del singolo elemento, si assicura che la dimensione del set
 venga modificata correttamente anche senza controllarlo.</dd>
<dt>Pre-Condition:</dt>
<dd>il set e' stato inizializzato da intialize(). La collezione contiene le stesse entries del set.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una collezione inserendo tutti gli elementi inseriti all'interno del set da parte
 del metodo initialize(). Si mantengono nel set solo gli elementi presenti all'interno della collezione.
 Siccome la collezione coincide con il set, non sono stati rimossi elementi dal set e quindi
 il set non e' stato modificato.</dd>
<dt>Expected Results:</dt>
<dd><code>retainAll(coll)</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRetainAllExceptionIfCollectionIsNull()">
<h3>testRetainAllExceptionIfCollectionIsNull</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRetainAllExceptionIfCollectionIsNull</span>()</div>
<div class="block">Test del metodo <code>public Object retainAll(HCollection coll)</code>: testa che il metodo <code>retainAll</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui la collezione passata sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>containAll</code> qualora la collezione passata non sia valida.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize(). Collection che fa riferimento a null.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova a mantenere all'interno del set una collezione HCollection coll che pero' non fa riferimento ad alcuna collezione.
 L'operazione deve fallire perche' <code>null</code> non e' una collezione valida.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testToArrayEmptySet()">
<h3>testToArrayEmptySet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToArrayEmptySet</span>()</div>
<div class="block">Test del metodo <code>public Object[] toArray()</code>: Testo che, una volta svuotato il set, il metodo toArray() ritorni un array
 con nessun elemento al suo interno, ovvero un array vuoto di dimensione 0. Il set e l'array devono entrambi non contenere nulla.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo toArray() istanzi un array in memoria e che lo lasci vuoto correttamente.</dd>
<dt>Pre-Condition:</dt>
<dd>il set e' stata svuotata dal metodo clear()</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato. L'array ritornato ha lunghezza 0.</dd>
<dt>Test Description:</dt>
<dd>Si crea un array expected e viene lasciato vuoto. Il set e' poi svuotato.
 Si crea poi l'array actual invocando il metodo toArray() sull'entrySet. expected e actual devono essere uguali come sopra descritto.</dd>
<dt>Expected Results:</dt>
<dd>L'array ritornato deve essere uguale ad un array vuoto.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testToArraySafeChanges()">
<h3>testToArraySafeChanges</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToArraySafeChanges</span>()</div>
<div class="block">Test del metodo <code>public Object[] toArray()</code>: Testo che anche se l'array ritornato viene modificato, le modifiche non hanno nessuna ripercussione sull'array originale.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo toArray() ritorni un array che non e' in alcun modo vincolato con gli elementi
 inseriti all'interno del set. Una modifica ai suoi elementi non deve generare nessuna modifica alil set.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize(). Entry e non contenuta nel set originale.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato. L'array ritornato ha gli stessi elementi del set ad eccezione dell'elemento
 nella posizione 0 che e' diventato la HEntry e.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene l'array corrispondente alil set chiamando il metodo toArray().
 Si modifica poi l'elemento in posizione 0 dell'array inserendo una HEntry e non presente nel set che quindi sara' contenuta solo
 nell'array ma non nel set.
 Si testa poi con il metodo contains che la suddetta entry non sia presente all'interno del set.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testToArrayGivenArraySameInstance()">
<h3>testToArrayGivenArraySameInstance</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToArrayGivenArraySameInstance</span>()</div>
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array con abbastanza posti, ritorni l'array precedentemente fornito
 senza creare una nuova istanza. Il controllo viene effettuato controllando gli indirizzi di memoria degli array.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo toArray() non crei un nuovo array ma ritorni quello fornito come parametro con gli elementi
 inseriti al suo interno.</dd>
<dt>Pre-Condition:</dt>
<dd>set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato. Gli elementi del set sono stati inseriti nell'array fornito come parametro.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo array arr con la dimensione esattamente pari agli elementi presenti all'interno del set.
 Si ottiene poi l'array returned chiamando il metodo <code>toArray(Object[])</code> dell'entrySet.
 L'indirizzo di arr e returned deve essere lo stesso. L'uguaglianza e' verificata grazie all'operatore == che su tipi riferimento
 funziona confrontando gli indirizzi. (nel caso di JUnit tale operazione si ottiene usando il metodo <code>assertSame()</code>)</dd>
<dt>Expected Results:</dt>
<dd>L'uguaglianza tra indirizzi ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testToArrayGivenArrayNewInstance()">
<h3>testToArrayGivenArrayNewInstance</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToArrayGivenArrayNewInstance</span>()</div>
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array che non abbia abbastanza posti, non ritorni l'array precedentemente fornito
 bensi' una nuova istanza di <code>Object[]</code>. Il controllo viene effettuato controllando gli indirizzi di memoria degli array.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo toArray() crei un nuovo array e non ritorni quello fornito come parametro.</dd>
<dt>Pre-Condition:</dt>
<dd>set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato. Gli elementi del set sono stati inseriti in un nuovo array.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo array arr con la dimensione esattamente pari agli elementi presenti all'interno del set.
 Si ottiene poi l'array returned chiamando il metodo <code>toArray(Object[])</code>.
 L'indirizzo di arr e returned deve essere diverso. La disuguaglianza e' verificata grazie all'operatore == che su tipi riferimento
 funziona confrontando gli indirizzi. (nel caso di JUnit tale operazione si ottiene usando il metodo <code>assertSame()</code>)</dd>
<dt>Expected Results:</dt>
<dd>L'uguaglianza tra indirizzi ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testToArrayGivenArrayNullAfterElements()">
<h3>testToArrayGivenArrayNullAfterElements</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToArrayGivenArrayNullAfterElements</span>()</div>
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array con abbastanza posti, ritorni l'array precedentemente fornito
 aggiungendo <code>null</code> nei posti inutilizzati. Controlla inoltre che gli elementi siano esattamente quelli del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo <code>toArray(Object[])</code> inserisca <code>null</code> e che inoltre tutti gli elementi siano corretti.</dd>
<dt>Pre-Condition:</dt>
<dd>set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato. Gli elementi del set sono stati inseriti nell'array fornito come parametro. Null
 e' stato inserito nei posti aggiuntivi del set, se presenti.</dd>
<dt>Test Description:</dt>
<dd>Si crea un array che abbia dimensione del set piu' un numero di posti aggiuntivo pari a <code>expectedNullElements</code>.
 Si invoca poi il metodo <code>toArray(Object[])</code> passando come parametro tale array.
 A partire dalla posizione pari a list.size() si contano nella variabile <code>actualNullElements</code> il numero di elementi
 posti effettivamente a null nell'array. Devono essere tutti null, cioe' <code>actualNullElements == expectedNullElements</code>.</dd>
<dt>Expected Results:</dt>
<dd>L'uguaglianza tra i due valori ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testToArrayGivenArraySameInstanceCorrectness()">
<h3>testToArrayGivenArraySameInstanceCorrectness</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToArrayGivenArraySameInstanceCorrectness</span>()</div>
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array con abbastanza posti, si ottiene l'array precedentemente fornito
 con che gli elementi che devono essere esattamente quelli del set e nello stesso ordine.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo <code>toArray(Object[])</code> inserisca tutti gli elementi correttamente nel caso in cui
 l'array di ritorno e' lo stesso fornito in precedenza.
 L'uguaglianza tra gli elementi del set e dell'array viene accertata mediante il metodo arrayEqualsAnyOrder: non e' possibile usare
 assertArrayEquals in quanto arrayEquals prevede l'uguaglianza non solo degli elementi, ma anche delle posizioni relative agli elementi.
 Tuttavia, per l'array ritornato da entrySet non e' data nessuna garanzia in merito all'ordinamento degli elementi, non e' possibile
 dunque fare supposizioni in merito.
 Il confronto viene eseguito usando il metodo <code>arrayEqualsAnyOrder</code> che controlla se gli elementi dei due array sono uguali
 tralasciando la loro posizione nell'array.
 Si usano due array separati per keys e values in quanto MyEntry e' una classe privata di MapAdapter e non usabile qui.</dd>
<dt>Pre-Condition:</dt>
<dd>set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato. Gli elementi del set sono stati inseriti nell'array fornito come parametro. Null
 e' stato inserito nei posti aggiuntivi del set, se presenti.</dd>
<dt>Test Description:</dt>
<dd>Si invoca il metodo <code>toArray()</code> per ottenere l'array associato alil set (si e' gia' testato
 in un'altra istanza che tale metodo e' corretto).
 Si crea un array che abbia dimensione del set piu' 2 posti (per avere un caso generale).
 Si invoca poi il metodo <code>toArray(Object[])</code> passando come parametro tale array.
 Si controlla poi che gli elementi siano gli stessi anche in posizioni diverse usando il metodo sopra citato.</dd>
<dt>Expected Results:</dt>
<dd><code>IsOk == true</code> alla fine del test.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testToArrayGivenArrayNewInstanceCorrectness()">
<h3>testToArrayGivenArrayNewInstanceCorrectness</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testToArrayGivenArrayNewInstanceCorrectness</span>()</div>
<div class="block">Testa il metodo <code>public Object[] toArray(Object[])</code>: fornendo un array che non abbia abbastanza posti, si ottiene un nuovo
 array che gli elementi che devono essere esattamente quelli del set e nello stesso ordine.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo <code>toArray(Object[])</code> inserisca tutti gli elementi correttamente nel caso in cui
 l'array di ritorno e' diverso da quello fornito come parametro.
 L'uguaglianza tra gli elementi del set e dell'array viene accertata mediante il metodo arrayEqualsAnyOrder: non e' possibile usare
 assertArrayEquals in quanto arrayEquals prevede l'uguaglianza non solo degli elementi, ma anche delle posizioni relative agli elementi.
 Tuttavia, per l'array ritornato da entrySet non e' data nessuna garanzia in merito all'ordinamento degli elementi, non e' possibile
 dunque fare supposizioni in merito.
 Il confronto viene eseguito usando il metodo <code>arrayEqualsAnyOrder</code> che controlla se gli elementi dei due array sono uguali
 tralasciando la loro posizione nell'array.
 Si usano due array separati per keys e values in quanto MyEntry e' una classe privata di MapAdapter e non usabile qui.</dd>
<dt>Pre-Condition:</dt>
<dd>set inizializzato con il metodo initialize(). I due array contenenti chiavi e valori inizializzati correttamente.</dd>
<dt>Post-Condition:</dt>
<dd>il set e' rimasto invariato. Gli elementi del set sono stati inseriti nell'array fornito come parametro.</dd>
<dt>Test Description:</dt>
<dd>Si invoca il metodo <code>toArray()</code> per ottenere l'array associato alil set (si e' gia' testato
 in un'altra istanza che tale metodo e' corretto).
 Si crea un array che abbia dimensione del set meno 2 posti (per avere un caso generale).
 Si invoca poi il metodo <code>toArray(Object[])</code> passando come parametro tale array.
 Si controlla poi che gli elementi siano gli stessi anche in posizioni diverse usando il metodo sopra citato.</dd>
<dt>Expected Results:</dt>
<dd>L'uguaglianza tra array deve ritornare <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddExceptionNotSupported()">
<h3>testAddExceptionNotSupported</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddExceptionNotSupported</span>()</div>
<div class="block">Test del metodo <code>public Object add(Object o)</code>: testa che il metodo <code>add</code> lanci eccezione
 <code>UnsupportedOperationException</code> nel caso in cui si provi ad invocarlo. Tale funzionalita'
 non e' infatti supportata dai Set ritornati dalla mappa</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>add</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova ad invocare il metodo add. L'operazione non puo' andare a buon fine perche'
 add non e' definito nel Set ritornato.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>UnsupportedOperationException</code> deve essere lanciata.
 Si controlla con il metodo <code>assertThrows()</code> fornito dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveReturnsTrueIfEntryWasInSet()">
<h3>testRemoveReturnsTrueIfEntryWasInSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveReturnsTrueIfEntryWasInSet</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di una entry
 che era presente all'interno dell'entrySet venga ritornato <code>true</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando la entry passata si trova nell'entrySet</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato rimosso una entry dal set, la dimensione e' diminuita di 1. L'entry e' quella passata come parametro.</dd>
<dt>Test Description:</dt>
<dd>Si crea un entrySet con il metodo <code>getSomeEntriesInMap()</code> che contiene alcune entries che sono
 all'interno dell'entrySet. Si rimuove una di queste entry e si testa se il metodo <code>remove(Object)</code> ha ritornato <code>true</code>.
 Siccome l'entry e' presente nella mappa e la mappa non e' stata modificata, la rimozione deve avere successo.</dd>
<dt>Expected Results:</dt>
<dd><code>remove</code> deve ritornare <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveReturnsFalseIfKeyIsInSetButValueIsNot()">
<h3>testRemoveReturnsFalseIfKeyIsInSetButValueIsNot</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveReturnsFalseIfKeyIsInSetButValueIsNot</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di una entry che non era presente
 all'interno del set venga ritornato <code>false</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando la entry passata non si trova nell'entrySet
 In particolare, in questo caso si accerta il funzionamento corretto quando la chiave e' presente in una delle entry ma il valore e'
 diverso. (La entry complessivamente e' dunque diversa).</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato</dd>
<dt>Test Description:</dt>
<dd>Si ottiene un set contenente entry che hanno la stessa chiave degli elementi nell'entryset ma valore diverso.
 Si prende una di queste entry e la si prova a rimuovere dalla mappa. Siccome tale entry non era stata precedentemente inserita nel set, questa
 non era presente e quindi <code>remove</code> deve ritornare <code>false</code>.

 Si testa il percorso di quando la chiave ha un valore associato nella mappa ma il valore inserito e' diverso per cui l'equals di entries fallisce.</dd>
<dt>Expected Results:</dt>
<dd><code>remove</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveReturnsFalseIfBothKeyAndValueNotInSet()">
<h3>testRemoveReturnsFalseIfBothKeyAndValueNotInSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveReturnsFalseIfBothKeyAndValueNotInSet</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la rimozione di un elemento che non era presente
 all'interno del set venga ritornato <code>false</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando la entry passata non si trova nell'entrySet
 In particolare, in questo caso si accerta il funzionamento corretto quando sia il valore che la chiave non sono presenti all'interno del set.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato</dd>
<dt>Test Description:</dt>
<dd>Si ottiene un set contenente entry che hanno chiave e valore diverso da quello nell'entrySet.
 Si prende una di queste entry e la si prova a rimuovere dalla mappa. Siccome tale entry non era stata precedentemente inserita nel set, questa
 non era presente e quindi <code>remove</code> deve ritornare <code>false</code>.

 Si testa il percorso di quando la chiave non e' presente nella mappa e l'invocazione di get ritorna null.</dd>
<dt>Expected Results:</dt>
<dd><code>remove</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveRemovesEntryFromSet()">
<h3>testRemoveRemovesEntryFromSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveRemovesEntryFromSet</span>()</div>
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando una entry all'interno del set,
 rimuova effettivamente l'elemento dal set. Dopo la rimozione l'elemento non deve essere piu' presente.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>remove</code> con rimozione dell'elemento dal set a cui apparteneva.</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet creato dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>L'entry passata al metodo remove e' stata rimossa dal set. La dimensione e' diminuita di 1.</dd>
<dt>Test Description:</dt>
<dd>Si crea un entrySet con il metodo <code>getSomeEntriesInMap()</code> che contiene alcune entries che sono
 all'interno dell'entrySet. Si rimuove una di queste entry.
 Siccome l'entry era presente nel set, dopo aver invocato <code>remove</code> tale entry non deve piu' essere presente.
 Si chiama il metodo contains passando l'entry rimossa per verificare che l'entry non sia piu' presente</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveExceptionIfEntryIsNull()">
<h3>testRemoveExceptionIfEntryIsNull</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveExceptionIfEntryIsNull</span>()</div>
<div class="block">Test del metodo <code>public Object remove(Object o)</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui il valore passato sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>remove</code> qualora il valore non sia valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere il valore nullo. Essendo null un elemento non valido per il set,
 deve essere sollevata eccezione: la rimozione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveThrowsExceptionIfNotEntry()">
<h3>testRemoveThrowsExceptionIfNotEntry</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveThrowsExceptionIfNotEntry</span>()</div>
<div class="block">Test del metodo <code>public Object remove(Object o)</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>ClassCastException</code> nel caso in cui il valore passato non sia una Entry.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>remove</code> qualora il valore fornito non sia valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere un valore che non sia una entry.
 Dal momento che il set contiene entries, non deve essere possibile rimuovere elementi che non siano entry, quindi il parametro non e' valido.
 Essendo il parametro non valido bisogna lanciare eccezione: la rimozione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>ClassCastException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsTrueIfEntryIsInMap()">
<h3>testContainsTrueIfEntryIsInMap</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsTrueIfEntryIsInMap</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>true</code>
 quando si cerca un'entry che e' presente all'interno del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>contains</code> quando la entry passata si trova nell'entrySet</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet inizializzato dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato</dd>
<dt>Test Description:</dt>
<dd>Si crea un entrySet con il metodo <code>getSomeEntriesInMap()</code> che contiene alcune entries che sono
 all'interno dell'entrySet. Si prende una di queste entry che viene passata al metodo <code>contains</code>.
 L'entry deve essere presente all'interno del set.

 Si testa il percorso di quando la chiave ha un valore associato nella mappa e il valore inserito e' uguale per cui l'equals di entries
 ha successo.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> deve ritornare <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsFalseIfKeyIsInMapButValueIsNot()">
<h3>testContainsFalseIfKeyIsInMapButValueIsNot</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsFalseIfKeyIsInMapButValueIsNot</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>false</code>
 quando si cerca un'entry che non e' presente all'interno del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>contains</code> quando la entry passata non si trova nell'entrySet
 In particolare, in questo caso si accerta il funzionamento corretto quando la chiave e' presente in una delle entry ma il valore e'
 diverso. (La entry complessivamente e' dunque diversa)</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato</dd>
<dt>Test Description:</dt>
<dd>Si ottiene un set contenente entry che hanno la stessa chiave degli elementi nell'entryset ma valore diverso.
 Si prende una di queste entry e la si prova a rimuovere dalla mappa. Siccome tale entry non era stata precedentemente inserita nel set, questa
 non era presente e quindi <code>contains</code> deve ritornare <code>false</code>.

 Si testa il percorso di quando la chiave ha un valore associato nella mappa ma il valore inserito e' diverso per cui l'equals di entries fallisce.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsReturnsFalseIfBothKeyAndValueNotInSet()">
<h3>testContainsReturnsFalseIfBothKeyAndValueNotInSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsReturnsFalseIfBothKeyAndValueNotInSet</span>()</div>
<div class="block">Test del metodo <code>public boolean contains (Object o)</code>: testa che il metodo <code>contains</code> ritorni <code>false</code>
 quando si cerca un'entry che non e' presente all'interno del set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>contains</code> quando la entry passata non si trova nell'entrySet
 In particolare, in questo caso si accerta il funzionamento corretto quando sia il valore che la chiave non sono presenti all'interno del set.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato</dd>
<dt>Test Description:</dt>
<dd>Si ottiene un set contenente entry che hanno chiave e valore diverso da quello nell'entrySet.
 Si prende una di queste entry e si prova a vedere se e' presente all'interno del set con il metodo contains.
 Siccome tale entry non era stata precedentemente inserita nel set, questa non puo' essere presente.

 Si testa il percorso di quando la chiave non e' presente nella mappa e l'invocazione di get ritorna null.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsExceptionIfNotEntry()">
<h3>testContainsExceptionIfNotEntry</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsExceptionIfNotEntry</span>()</div>
<div class="block">Test del metodo <code>public Object contains(Object o)</code>: testa che il metodo <code>contains</code> lanci eccezione
 <code>ClassCastException</code> nel caso in cui il valore passato non sia una Entry.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>contains</code> qualora il valore fornito non sia valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova a vedere se un valore che non e' una entry e' presente all'interno del set.
 Dal momento che il set contiene entries, non deve essere possibile ispezionare elementi che non siano entry, quindi il parametro non e' valido.
 Essendo il parametro non valido bisogna lanciare eccezione: l'ispezione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>ClassCastException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsExceptionIfNullParam()">
<h3>testContainsExceptionIfNullParam</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsExceptionIfNullParam</span>()</div>
<div class="block">Test del metodo <code>public Object contains(Object o)</code>: testa che il metodo <code>contains</code> lanci eccezione
 <code>NullPointerException</code> nel caso in cui il valore passato sia <code>null</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto funzionamento di <code>contains</code> qualora il valore non sia valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si prova ad ispezionare il valore nullo. Essendo null un elemento non valido per il set,
 deve essere sollevata eccezione: l'ispezione non puo' andare a buon fine.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NullPointerException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testEqualsSameEntries()">
<h3>testEqualsSameEntries</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testEqualsSameEntries</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 entrySet con gli stessi elementi
 siano uguali usando il metodo <code>equals</code>.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionmento del metodo <code>equals</code> per cui quando si hanno 2 set uguali venga ritornato true.</dd>
<dt>Pre-Condition:</dt>
<dd>Set creato dal metodo initialize(). EntrySet inizializzato con i valori ritornati dall'iteratore di entryset</dd>
<dt>Post-Condition:</dt>
<dd>Nessuno dei 2 set e' stato modificato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova mappa con gli stessi elementi della mappa originale.
 Per quanto dichiarato dalla documentazione, i due entryset ritornati dalle 2 mappe sono uguali. Il controllo viene fatto usando equals()</dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testEqualsDifferentSize()">
<h3>testEqualsDifferentSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testEqualsDifferentSize</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 entryset con un numero di elementi diversi non siano uguali.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionmento del metodo <code>equals</code> per cui quando si hanno 2 entrySet diversi venga ritornato
 <code>false</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Set creato dal metodo initialize(). Secondo entrySet contenente una parte degli elementi della mappa originale.</dd>
<dt>Post-Condition:</dt>
<dd>Nessuno dei due set e' stato modificato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova mappa con solo una parte degli elementi della mappa originale.
 Per quanto dichiarato dalla documentazione, i due entryset ritornati dalle 2 mappe sono diversi. Il controllo viene fatto usando equals()</dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testEqualsDifferentEntries()">
<h3>testEqualsDifferentEntries</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testEqualsDifferentEntries</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che 2 entryset con lo stesso numero di elementi ma con
 almeno un'entry diversa siano diversi.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionmento del metodo <code>equals</code> per cui quando si hanno 2 entrySet diversi venga ritornato
 <code>false</code>. Si testa il caso in cui un valore e' diverso, ma le 3 casistiche (stessa chiave valore diverso, stesso valore chiave diversa,
 sia chiave che valori diversi) sono uguali tra loro per come e' stato scritto il codice del metodo.</dd>
<dt>Pre-Condition:</dt>
<dd>Set creato dal metodo initialize(). Secondo entrySet contenente una parte degli elementi della mappa originale.</dd>
<dt>Post-Condition:</dt>
<dd>Nessuno dei due set e' stato modificato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova mappa con 2 entries uguali a quelle della mappa originale e una che differisce
 per il valore.
 Per quanto dichiarato dalla documentazione, i due entryset ritornati dalle 2 mappe sono diversi. Il controllo viene fatto usando equals()</dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testEqualsFailIsNull()">
<h3>testEqualsFailIsNull</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testEqualsFailIsNull</span>()</div>
<div class="block">Test del metodo <code>public boolean equals(Object o)</code>: testo che se l'argomento passato e' <code>null</code> il metodo
 ritorni false.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionmento del metodo <code>equals</code> per cui quando il parametro passato e' nullo venga ritornato
 false. Si verifica che non sia lanciata eccezione erroneamente.</dd>
<dt>Pre-Condition:</dt>
<dd>Set creato dal metodo initialize(). Collezione inizializzata a null.</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una nuova collection e la si inizializza con il valore null.
 Per quanto dichiarato dalla documentazione, i due set non sono uguali. Il controllo viene fatto usando <code>equals</code></dd>
<dt>Expected Results:</dt>
<dd>il metodo <code>equals</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testHashCodeSameSets()">
<h3>testHashCodeSameSets</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testHashCodeSameSets</span>()</div>
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 entrySet uguali abbiano lo stesso hashCode</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>due entryset uguali hanno lo stesso codice hash.</dd>
<dt>Pre-Condition:</dt>
<dd>2 entryset opportunamente creati uguali tra loro secondo i parametri definiti da equals (stesse coppie
 chiave valori nelle entries).</dd>
<dt>Post-Condition:</dt>
<dd>i set sono rimasti invariati</dd>
<dt>Test Description:</dt>
<dd>Creazione di un nuovo oggetto MapAdapter. Ad entrambe le mappe esistenti, aggiungo gli stessi elementi definiti dal
 metodo initialize(). Dalle due mappe ottengo gli entrySet e ne calcolo l'hashCode</dd>
<dt>Expected Results:</dt>
<dd>I due entrySet hanno lo stesso hashCode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testHashCodeDifferentSets()">
<h3>testHashCodeDifferentSets</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testHashCodeDifferentSets</span>()</div>
<div class="block">Test del metodo <code>public int hashCode()</code>: Si testa che 2 set diversi, anche parzialmente, abbiano due codici
 hash diversi.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>due set diversi hanno codici hash diversi. Si testa inserendo nel set elementi comuni e non</dd>
<dt>Pre-Condition:</dt>
<dd>2 set con entries almeno in parte diverse per quanto definito da equals.</dd>
<dt>Post-Condition:</dt>
<dd>i set sono rimasti invariati</dd>
<dt>Test Description:</dt>
<dd>Creazione di un nuovo oggetto MapAdapter. Ad entrambe le mappe esistenti, aggiungo gli stessi elementi definiti dal
 metodo initialize(). Dalle due mappe ottengo gli entrySet e ne calcolo l'hashCode</dd>
<dt>Expected Results:</dt>
<dd>i due entrySet NON hanno lo stesso hashCode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveFailsSameSizeBacking()">
<h3>testRemoveFailsSameSizeBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveFailsSameSizeBacking</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: testa che il metodo <code>remove</code> dopo la tentata rimozione di un elemento
 che non era presente all'interno del set abbia lasciato invariata la dimensione del set.
 Dal momento che la size() ritornata da set e' la stessa che viene ritornata da map (e' un metodo wrapper) considero quella di map.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di <code>remove</code> quando la entry passata non si trova nell'entrySet
 Si vuole che quando l'elemento non sia presente nel set(quindi nella mappa) la rimozione non abbia successo e che quindi la dimensione sia la
 stessa (ad esempio sono sicuro che non venga rimosso un elemento a caso).</dd>
<dt>Pre-Condition:</dt>
<dd>Set inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>Il set e' rimasto invariato. La dimensione e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Dopo aver salvato la dimensione della mappa, si ottiene un set contente entry che non sono presenti nell'entryset.
 Si prende una di queste entry e la si prova a rimuovere dalla mappa. Siccome tale entry non era stata precedentemente inserita nel set, questa
 non era presente e quindi remove non deve far nulla se non ritornare <code>false</code>.
 Testo dunque mediante il metodo <code>size</code> che la dimensione sia rimasta invariata.</dd>
<dt>Expected Results:</dt>
<dd><code>size</code> deve ritornare la dimensione precedentemente salvata.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testClearBacking()">
<h3>testClearBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testClearBacking</span>()</div>
<div class="block">Test del metodo <code>public void clear()</code>: testo che facendo il clear sull'entrySet, nella mappa siano stati
 cancellati tutti gli elementi.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che clear cancelli gli elementi della mappa quando invocato su un entrySet.</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet inizializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La mappa e il set sono vuoti</dd>
<dt>Test Description:</dt>
<dd>Prendo l'entrySet generato dalla mappa e su di esso invoco il metodo clear. La mappa deve essere vuota,
 testo cio' invocando il metodo isEmpty di map</dd>
<dt>Expected Results:</dt>
<dd><code>isEmpty</code> ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testEntrySetValueBacking()">
<h3>testEntrySetValueBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testEntrySetValueBacking</span>()</div>
<div class="block">Test del metodo <code>public Object setValue(Object o)</code>: Testo che se un valore viene modificato usando il metodo <code>setValue</code>
 definito nella classe Entry, questo venga modificato anche nella mappa che contiene tale entry.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento della proprieta' di backing quando si esegue il set in un'entry.</dd>
<dt>Pre-Condition:</dt>
<dd>EntrySet inzializzato dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato sostituito un elemento sia nell'entry che nella mappa.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene un'entry dall'entrySet.
 Si sostituisce il valore della entry usando il metodo <code>setValue</code>
 Per verificare che la modifica abbia avuto ripercussioni si chiama il metodo containsValue passando il valore appena inserito.</dd>
<dt>Expected Results:</dt>
<dd><code>containsValue</code> deve ritornare <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveRemovesEntryFromMapBacking()">
<h3>testRemoveRemovesEntryFromMapBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveRemovesEntryFromMapBacking</span>()</div>
<div class="block">Test del metodo <code>public void boolean remove(Object o)</code>: Testo che l'invocazione di <code>remove</code> passando una entry all'interno del set,
 rimuova l'elemento dalla mappa oltre che dal set.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento di backing di <code>remove</code> con rimozione dell'elemento dalla mappa a cui apparteneva.</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet creato dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>L'entry passata al metodo remove e' stata rimossa dalla mappa.</dd>
<dt>Test Description:</dt>
<dd>Si crea un entrySet con il metodo <code>getSomeEntriesInMap()</code> che contiene alcune entries che sono
 all'interno dell'entrySet. Si rimuove una di queste entry.
 Siccome l'entry era presente nel set, dopo aver invocato <code>remove</code> tale entry non deve piu' essere presente.
 Per la proprieta' di backing, siccome l'elemento e' stato rimosso dal set, questo deve essere stato rimosso anche dalla mappa.
 Si chiama il metodo contains passando l'entry rimossa per verificare che l'entry non sia piu' presente.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveAllBackingWhenElementsAreRemoved()">
<h3>testRemoveAllBackingWhenElementsAreRemoved</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveAllBackingWhenElementsAreRemoved</span>()</div>
<div class="block">Test del metodo <code>public void boolean removeAll(Object o)</code>: Testo che l'invocazione di <code>removeAll</code> passando un entrySet contenente
 alcune entries che sono presenti all'interno della mappa, rimuova tali entries dalla mappa stessa.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento di backing di <code>removeAll</code> con rimozione degli elementi dalla mappa a cui apparteneva.
 Si verifica solo quando entries vengono rimosse: si e' gia' verificato in precedenza che removeAll funziona con entries non
 contenute nella mappa.</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet creato dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>Le entries contenute nel set sono state rimosse dalla mappa.</dd>
<dt>Test Description:</dt>
<dd>Si crea un entrySet con il metodo <code>getSomeEntriesInMap()</code> che contiene alcune entries che sono
 all'interno dell'entrySet. Si rimuovono queste entry.
 Siccome le entries erano presenti nel set, dopo aver invocato <code>removeAll</code> tali entry non devono piu' essere presenti.
 Per la proprieta' di backing, siccome gli elementi sono stati rimossi dal set, questi devono essere stati rimossi anche dalla mappa.
 Per ciascuna entry eliminata si verifica che sia il valore (inseriti appositamente in modo unico) che la chiave siano stati rimossi
 dalla mappa.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code> per tutte le chiavi e tutti i valori.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRetainAllBackingWhenElementsAreRemoved()">
<h3>testRetainAllBackingWhenElementsAreRemoved</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRetainAllBackingWhenElementsAreRemoved</span>()</div>
<div class="block">Test del metodo <code>public void boolean retainAll(Object o)</code>: Testo che l'invocazione di <code>retainAll</code> passando un entrySet contenente
 alcune entries che sono presenti all'interno della mappa, rimuova le entries non presenti nel set dalla mappa.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento di backing di <code>retainAll</code> con rimozione degli elementi dalla mappa.
 Si verifica solo quando entries vengono rimosse: si e' gia' verificato in precedenza che retainAll funziona con entries non
 contenute nella mappa.</dd>
<dt>Pre-Condition:</dt>
<dd>entrySet creato dal metodo <code>initialize</code></dd>
<dt>Post-Condition:</dt>
<dd>Le entries contenute nel set sono state mantenute nella mappa.</dd>
<dt>Test Description:</dt>
<dd>Si crea un entrySet con il metodo <code>getSomeEntriesInMap()</code> che contiene alcune entries che sono
 all'interno dell'entrySet. Si mantengono queste entry.
 Siccome le entries erano presenti nel set, dopo aver invocato <code>retainAll</code> tali entry devono essere le uniche presenti.
 Per la proprieta' di backing, siccome gli elementi sono stati rimossi dal set, questi devono essere stati rimossi anche dalla mappa.
 Per ciascuna entry eliminata si verifica che sia il valore (inseriti appositamente in modo unico) che la chiave devono essere presenti
 nella mappa.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code> per tutte le chiavi e tutti i valori.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSetSomeEntriesInMap()">
<h3>getSetSomeEntriesInMap</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></span>&nbsp;<span class="member-name">getSetSomeEntriesInMap</span>()</div>
<div class="block">Ritorna un entrySet con alcune Entry presenti all'interno dell'oggetto MapAdapter usato per effettuare i test.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>un entrySet come sopra specificato</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSetMixedEntries()">
<h3>getSetMixedEntries</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></span>&nbsp;<span class="member-name">getSetMixedEntries</span>()</div>
<div class="block">Ritorna un entrySet con alcune Entry presenti all'interno dell'oggetto MapAdapter usato per effettuare i test e altre
 che invece non sono presenti.<p>
 Le entry non presenti possono differiscono solo per chiave, solo per valore o entrambi.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>un entrySet come sopra specificato</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSetEntriesKeyInMapButDifferentValue()">
<h3>getSetEntriesKeyInMapButDifferentValue</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></span>&nbsp;<span class="member-name">getSetEntriesKeyInMapButDifferentValue</span>()</div>
<div class="block">Ritorna un entrySet con delle Entry che non sono presenti nell'oggetto MapAdapter usato per sviluppare i test.
 Le entry differiscono per il valore. Le chiavi sono presenti nell'oggetto MapAdapter.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>un entrySet come sopra specificato</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSetEntriesNeitherKeyNorValueInMap()">
<h3>getSetEntriesNeitherKeyNorValueInMap</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></span>&nbsp;<span class="member-name">getSetEntriesNeitherKeyNorValueInMap</span>()</div>
<div class="block">Ritorna un entrySet con delle Entry che non sono presenti nell'oggetto MapAdapter usato per sviluppare i test.
 Le entry differiscono sia per valore che per chiave.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>un entrySet come sopra specificato</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getSetEntriesNotInMap()">
<h3>getSetEntriesNotInMap</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HSet.html" title="interface in myAdapter">HSet</a></span>&nbsp;<span class="member-name">getSetEntriesNotInMap</span>()</div>
<div class="block">Ritorna un entrySet con delle Entry che non sono presenti nell'oggetto MapAdapter usato per sviluppare i test.
 Le entry differiscono per valore, chiave o entrambi.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>un entrySet come sopra specificato</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="arrayEqualsAnyOrder(java.lang.Object[],java.lang.Object[],java.lang.Object[],int)">
<h3>arrayEqualsAnyOrder</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="member-name">arrayEqualsAnyOrder</span>&#8203;(<span class="parameters">java.lang.Object[]&nbsp;keys,
java.lang.Object[]&nbsp;values,
java.lang.Object[]&nbsp;entries,
int&nbsp;invalidElementsInEntries)</span></div>
<div class="block">Controlla che due array siano uguali in qualsiasi ordine.
 Se alla fine dell'array sono presenti elementi non validi, questa informazione viene passata al metodo
 usando il parametro invalidElementsInEntries: tali valori non verranno considerati per determinare l'uguaglianza.</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
