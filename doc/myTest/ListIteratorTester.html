<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Fri May 14 13:46:40 CEST 2021 -->
<title>ListIteratorTester</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-05-14">
<meta name="description" content="declaration: package: myTest, class: ListIteratorTester">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">myTest</a></div>
<h1 title="Class ListIteratorTester" class="title">Class ListIteratorTester</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">myTest.ListIteratorTester</div>
</div>
<section class="description">
<hr>
<pre>public class <span class="type-name-label">ListIteratorTester</span>
extends java.lang.Object</pre>
<div class="block">Questa suite di test ha il compito di testare tutte le funzionalita' dell'iteratore che opera su un oggetto di tipo <code>ListAdapter</code>.<p>
 In questa suite verranno testati i metodi della classe <code>ListIter</code>, la quale implementa i metodi definiti dall'interfaccia
 HListIterator (che estende l'interfaccia HIterator, quindi anche i metodi dell'iteratore di base sono testati qui di seguito).<p>
 Il corretto comportamento di backing della sottolista e le funzionalita' di base dell'oggetto ListAdapter sono testate in una diversa suite.
 Si vuole dimostrare che tutti i metodi definiti in <code>ListIter</code> funzionino correttamente.<p></div>
<dl class="notes">
<dt>Author:</dt>
<dd>Formaggio Alberto</dd>
<dt>See Also:</dt>
<dd><a href="ListAdapterTester.html" title="class in myTest"><code>ListAdapterTester</code></a></dd>
<dt><b>Test Suite Design:</b></dt>
<dd>Per testare la classe nella sua interezza e' stato testato ciascun metodo fornendo in input parametri validi
 e non validi oltre a testare le varie configurazioni tra metodi cosi' da testare il piu' ampio numero di casi possibili in cui
 l'iteratore puo' trovarsi.<p>
 La documentazione di ciascun test case e' stata eseguita seguendo la colonna "homework" fornita nel file della consegna,
 inoltre i metodi hanno tutti un nome che e' il piu' evocativo possibile.</dd>
<dt><b>Pre-Condition:</b></dt>
<dd>Si suppone che i metodi della classe ListAdapter siano gia' stati testati all'interno di un'altra suite.</dd>
<dt><b>Post-Condition:</b></dt>
<dd>Si sono ottenuti i risultati dell'esecuzione di tutti i test in questa suite.</dd>
<dt>Test Suite Execution Records:</dt>
<dd>Consultare il file <a href="..\..\Test suite execution records\Test Results - ListIteratorTester.html">
     "Test Results - ListIteratorTester.html"</a> nella cartella "Test suite execution records"</dd>
<dt>Execution Variables:</dt>
<dd>I test sono stati eseguiti utilizzando JUnit v4.13 e hamcrest v1.3.
 Per poter lanciare i test e' necessario inserire i file .jar di questi framework all'interno del CLASSPATH settando tale
 variabile di ambiente.</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>private <a href="../myAdapter/ListAdapter.html" title="class in myAdapter">ListAdapter</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#list">list</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>private <a href="../myAdapter/HListIterator.html" title="interface in myAdapter">HListIterator</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#lit">lit</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">ListIteratorTester</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#Initialize()">Initialize</a></span>()</code></th>
<td class="col-last">
<div class="block">Inizializza un oggetto inserendo 3 valori in ordine 0,1,2.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddAtBeginning()">testAddAtBeginning</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void add(Object o)</code>: testa che il metodo add inserisca nella prima posizione della lista
 subito dopo aver creato l'iteratore.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddAtEnd()">testAddAtEnd</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void add(Object o)</code>: testa che il metodo add inserisca correttamente alla fine della
 lista.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddInEmptyList()">testAddInEmptyList</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void add(Object o)</code>: testa che il metodo add inserisca correttamente all'interno della lista
 se la lista e' vuota.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddInMiddle()">testAddInMiddle</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void add(Object o)</code>: testa che il metodo add inserisca correttamente in una posizione intermedia della
 lista.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddNextReturnNextElement()">testAddNextReturnNextElement</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void add(Object o)</code>: Testo che dopo una chiamata al metodo next dopo l'inserimento ritorni
 l'elemento successivo a quello appena inserito.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddPreviousReturnElementJustInserted()">testAddPreviousReturnElementJustInserted</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void add(Object o)</code>: Testo che dopo una chiamata al metodo previous dopo l'inserimento ritorni
 l'elemento appena inserito.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testHasNextWhenThereIsNext()">testHasNextWhenThereIsNext</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean hasNext()</code>: Testa HasNext quando l'iteratore non ha ispezionato tutti gli elementi</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testHasNextWhenThereIsNotNext()">testHasNextWhenThereIsNotNext</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean hasNext()</code>: Testa HasNext quando l'iteratore e' arrivato alla fine della scansione</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testNextAtBeginning()">testNextAtBeginning</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object next()</code>: Testa <code>next</code> quando l'iteratore e' appena stato creato.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testNextElementsAreInOrder()">testNextElementsAreInOrder</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object next()</code>: Testa che tutti gli elementi siano nello stesso ordine definito dalla lista.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testNextExceptionIfThereIsNotNext()">testNextExceptionIfThereIsNotNext</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object next()</code>: testa che il metodo <code>next</code> lanci eccezione
 <code>NoSuchElementException</code> nel caso in cui si provi ad ottenere un elemento con next quando l'iteratore ha gia'
 raggiunto la fine della lista.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testNextIndexAtAnyPosition()">testNextIndexAtAnyPosition</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int nextIndex()</code>: testa che il valore ritornato da nextIndex sia l'indice dell'elemento ritornato
 da una successiva chimata al metodo next.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testNextIndexAtEndOfList()">testNextIndexAtEndOfList</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int nextIndex()</code>: testa che se si e' alla fine della lista, il valore ritornato sia pari
 alla dimensione della lista.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testNextInMiddle()">testNextInMiddle</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object next()</code>: Testa che <code>next()</code> ritorni l'elemento corretto anche dopo che next() e' gia' stato invocato una volta, ovvero testo
 che l'elemento ispezionato sia corretto anche all'interno della lista e non solo all'inizio.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testNextWorksFineAfterRemove()">testNextWorksFineAfterRemove</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lasci l'iteratore in uno stato corretto.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPreviousAtBeginningOfList()">testPreviousAtBeginningOfList</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int nextIndex()</code>: testa che se si e' alla fine della lista, il valore ritornato sia -1</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPreviousExceptionIfThereIsNotPrevious()">testPreviousExceptionIfThereIsNotPrevious</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object previous()</code>: testa che il metodo <code>previous</code> lanci eccezione
 <code>NoSuchElementException</code> nel caso in cui si provi ad ottenere un elemento con previous quando l'iteratore ha gia'
 raggiunto l'inizio della lista.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPreviousGetSameElementAsNext()">testPreviousGetSameElementAsNext</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object previous()</code>: Si testa il comportamento di previous quando si va avanti di una posizione e poi si torna indietro.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPreviousIndexInAnyPosition()">testPreviousIndexInAnyPosition</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int previousIndex()</code>: testa che il valore ritornato da nextIndex sia l'indice dell'elemento ritornato
 da una successiva chimata al metodo previous.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPreviousNextCorrectOrder()">testPreviousNextCorrectOrder</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object previous()</code> e <code>public Object next()</code>: Testa che gli elementi vengano ritornati
 nell'ordine corretto scansionando la lista da inizio a fine e poi da fine a inizio.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPreviousScanInReverseOrder()">testPreviousScanInReverseOrder</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object previous()</code>: Testa che tutti gli elementi siano nello stesso ordine definito dalla lista.</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testPreviousWorksFineAfterRemove()">testPreviousWorksFineAfterRemove</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lasci l'iteratore in uno stato corretto.</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveExceptionCallingRemoveTwice()">testRemoveExceptionCallingRemoveTwice</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a chiamare il metodo remove due volte di fila senza aver chiamato next
 prima della seconda rimozione.</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveExceptionIfNextWasNotInvoked()">testRemoveExceptionIfNextWasNotInvoked</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a rimuovere un elemento senza che nessuno sia mai stato invocato in precedenza.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveRemovesFromList()">testRemoveRemovesFromList</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> rimuova l'elemento dalla lista</div>
</td>
</tr>
<tr class="alt-color" id="i26">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveRemovesFromListAfterPrevious()">testRemoveRemovesFromListAfterPrevious</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> rimuova l'elemento dalla lista appena
 restituito dal metodo previous.</div>
</td>
</tr>
<tr class="row-color" id="i27">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveThrowsExceptionAfterAdd()">testRemoveThrowsExceptionAfterAdd</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a chiamare il metodo <code>remove</code> subito dopo aver invocato il metodo <code>add</code>
 senza aver chiamato next.</div>
</td>
</tr>
<tr class="alt-color" id="i28">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSetAfterNext()">testSetAfterNext</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object set(Object o)</code>: testa che il metodo <code>set</code> sostituisca l'elemento ritornato dall'ultima
 invocazione del metodo next.</div>
</td>
</tr>
<tr class="row-color" id="i29">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSetAfterPrevious()">testSetAfterPrevious</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object set(Object o)</code>: testa che il metodo <code>set</code> sostituisca l'elemento ritornato dall'ultima
 invocazione del metodo previous.</div>
</td>
</tr>
<tr class="alt-color" id="i30">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSetExceptionAfterAdd()">testSetExceptionAfterAdd</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void set()</code>: testa che il metodo <code>set</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a chiamare il metodo set subito dopo aver invocato il metodo add
 senza una precedente invocazione del metodo next o previous.</div>
</td>
</tr>
<tr class="row-color" id="i31">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSetExceptionAfterRemove()">testSetExceptionAfterRemove</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void set()</code>: testa che il metodo <code>set</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a chiamare il metodo set subito dopo aver invocato il metodo remove
 senza una precedente invocazione del metodo next o previous.</div>
</td>
</tr>
<tr class="alt-color" id="i32">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSetMultipleSet()">testSetMultipleSet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void set(Object o)</code>: testa che il metodo <code>set</code> non lanci eccezione
 nel caso in cui si provi a settare 2 volte uno stesso elemento.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="list">
<h3>list</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/ListAdapter.html" title="class in myAdapter">ListAdapter</a></span>&nbsp;<span class="member-name">list</span></div>
</section>
</li>
<li>
<section class="detail" id="lit">
<h3>lit</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HListIterator.html" title="interface in myAdapter">HListIterator</a></span>&nbsp;<span class="member-name">lit</span></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>ListIteratorTester</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">ListIteratorTester</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="Initialize()">
<h3>Initialize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">Initialize</span>()</div>
<div class="block">Inizializza un oggetto inserendo 3 valori in ordine 0,1,2. Al termine della creazione la lista su cui verrano eseguiti i test sara'
 fatta nel seguente modo: <pre>
 list
 | 0 | 1 | 2 |
</pre>
 Crea l'iteratore di tipo HListIterator per tale lista.</div>
</section>
</li>
<li>
<section class="detail" id="testNextElementsAreInOrder()">
<h3>testNextElementsAreInOrder</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testNextElementsAreInOrder</span>()</div>
<div class="block">Test del metodo <code>public Object next()</code>: Testa che tutti gli elementi siano nello stesso ordine definito dalla lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che ci sia corrispondenza tra gli elementi della lista e i valori ritornati dalle successive invocazioni
 di <code>next()</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando al primo elemento. Iteratore
 creato.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore e' arrivato alla fine della lista. La lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo iteratore e si testa che gli elementi ottenuti da <code>next</code> siano gli stessi nella posizione i-esima della
 lista usando il metodo <code>get</code>. Si usa una variabile booleana isOk che viene settata a <code>false</code> se un'operazione di controllo
 ha un riscontro fallimentare.</dd>
<dt>Expected Results:</dt>
<dd>isOk deve essere <code>true</code>, ovvero l'ordine dato dall'iteratore deve essere esattamente quello della lista.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testHasNextWhenThereIsNext()">
<h3>testHasNextWhenThereIsNext</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testHasNextWhenThereIsNext</span>()</div>
<div class="block">Test del metodo <code>public boolean hasNext()</code>: Testa HasNext quando l'iteratore non ha ispezionato tutti gli elementi</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>accertamento del funzionamento di hasNext in una posizione qualsiasi della lista</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo Initialize(). L'iteratore *non* sta puntando all'ultimo elemento</dd>
<dt>Post-Condition:</dt>
<dd>La lista ha creato un HIterator. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Presa una lista con almeno un elemento rimasto da ispezionare, si testa se l'iteratore ha un successivo</dd>
<dt>Expected Results:</dt>
<dd>Il test deve ritornare <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testHasNextWhenThereIsNotNext()">
<h3>testHasNextWhenThereIsNotNext</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testHasNextWhenThereIsNotNext</span>()</div>
<div class="block">Test del metodo <code>public boolean hasNext()</code>: Testa HasNext quando l'iteratore e' arrivato alla fine della scansione</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del funzionamento di hasNext alla fine della lista</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo Initialize(). L'iteratore sta puntando all'ultimo elemento</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore si e' spostato di una posizione. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Presa una lista con nessun un elemento rimasto da ispezionare, si testa se l'iteratore ha un successivo</dd>
<dt>Expected Results:</dt>
<dd>Il test deve ritornare <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testNextAtBeginning()">
<h3>testNextAtBeginning</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testNextAtBeginning</span>()</div>
<div class="block">Test del metodo <code>public Object next()</code>: Testa <code>next</code> quando l'iteratore e' appena stato creato.
 L'elemento ritornato deve essere il primo elemento della lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che l'inizializzazione di un iteratore sia corretta: alla creazione deve puntare al primo elemento della lista.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando al primo elemento. Iteratore
 creato.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore si e' spostato in avanti di una posizione. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo iteratore e si testa se il primo elemento ritornato dall'invocazione di next e' uguale al primo elemento
 della lista (ovvero lo 0).</dd>
<dt>Expected Results:</dt>
<dd>0 deve essere uguale all'elemento ritornato dall'iteratore.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testNextInMiddle()">
<h3>testNextInMiddle</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testNextInMiddle</span>()</div>
<div class="block">Test del metodo <code>public Object next()</code>: Testa che <code>next()</code> ritorni l'elemento corretto anche dopo che next() e' gia' stato invocato una volta, ovvero testo
 che l'elemento ispezionato sia corretto anche all'interno della lista e non solo all'inizio.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che lo spostamento dell'iteratore dopo un'invocazione sia corretto, ovvero che avanzi e non punti sempre
 alla stessa posizione.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando al primo elemento. Iteratore
 creato e spostato avanti di una posizione.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore si e' spostato in avanti di un'ulteriore posizione. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo iteratore e lo si sposta in avanti di una posizione. Si testa se la seconda invocazione di next()
 ritorna il secondo elemento della lista (ovvero l'1)</dd>
<dt>Expected Results:</dt>
<dd>1 deve essere uguale all'elemento ritornato dall'iteratore.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testNextExceptionIfThereIsNotNext()">
<h3>testNextExceptionIfThereIsNotNext</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testNextExceptionIfThereIsNotNext</span>()</div>
<div class="block">Test del metodo <code>public Object next()</code>: testa che il metodo <code>next</code> lanci eccezione
 <code>NoSuchElementException</code> nel caso in cui si provi ad ottenere un elemento con next quando l'iteratore ha gia'
 raggiunto la fine della lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento e sollevamento dell'eccezione quando non ci sono elementi da restituire.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando a dopo l'ultimo elemento.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore non ha subito modifiche. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si sposta tale iteratore fino alla fine della lista, in modo che it.hasNext() ritorni false.
 Si prova ora ad ottenere un nuovo elemento. Tale operazione non puo' avere successo perche' la lista non ha altri elementi da ritornare.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NoSuchElementException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveRemovesFromList()">
<h3>testRemoveRemovesFromList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveRemovesFromList</span>()</div>
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> rimuova l'elemento dalla lista</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento dell'iteratore quando si rimuove un elemento appena scansionato da next.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando ad un elemento qualsiasi nella lista.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore si e' posizionato correttamente tra il precedente e il successivo dell'elemento rimosso.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si sposta tale iteratore di 2 posizioni e si prende l'ultimo elemento
 ritornato dal meotodo next in una variabile chiamata <code>removed</code>.
 Si invoca poi il metodo <code>remove</code>.
 L'elemento precedentemente salvato non deve piu' essere presente all'interno della lista. Si controlla cio' mediante il metodo contains() della lista.
 Siccome l'elemento e' stato ottenuto dal metodo next prima era sicuramente all'interno della lista.</dd>
<dt>Expected Results:</dt>
<dd><code>contains(removed)</code> deve ritornare <code>false</code>, l'elemento e' stato rimosso dalla lista.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveExceptionIfNextWasNotInvoked()">
<h3>testRemoveExceptionIfNextWasNotInvoked</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveExceptionIfNextWasNotInvoked</span>()</div>
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a rimuovere un elemento senza che nessuno sia mai stato invocato in precedenza.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento e sollevamento dell'eccezione quando non ci sono elementi da restituire.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando al primo elemento.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore non ha subito modifiche. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si prova a rimuovere un elemento.
 Tale operazione non puo' avere successo perche' non e' stato ispezionato nessun elemento.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>IllegalStateException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveExceptionCallingRemoveTwice()">
<h3>testRemoveExceptionCallingRemoveTwice</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveExceptionCallingRemoveTwice</span>()</div>
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a chiamare il metodo remove due volte di fila senza aver chiamato next
 prima della seconda rimozione.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento e sollevamento dell'eccezione quando l'iteratore non e' in uno stato valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando al primo elemento.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore non e' stato modificato. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si ottiene un elemento con next che poi viene rimosso.
 Tale rimozione ha successo perche' prima ho invocato il metodo next.
 Una successiva invocazione deve sollevare eccezione perche' non ho scansionato un ulteriore elemento.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>IllegalStateException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testNextWorksFineAfterRemove()">
<h3>testNextWorksFineAfterRemove</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testNextWorksFineAfterRemove</span>()</div>
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lasci l'iteratore in uno stato corretto.
 Una volta rimosso l'elemento da una posizione, una successiva invocazione di next deve ritornare quello che ora e' andato al posto
 dell'elemento rimosso dalla lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento dell'iteratore quando ci si sposta con next dopo avere fatto una rimozione.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando ad un elemento qualsiasi nella lista.</dd>
<dt>Post-Condition:</dt>
<dd>L'elemento si e' spostato avanti di una posizione.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si sposta tale iteratore di una posizione e si rimuove un elemento.
 Senza l'elemento nella prima posizione, l'elemento che prima era nella seconda posizione (1) va all'inizio della lista.
 Un'invocazione di <code>next</code> deve ritornare il nuovo primo elemento della lista.</dd>
<dt>Expected Results:</dt>
<dd><code>next</code> deve ritornare 1 (il nuovo primo elemento della lista).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPreviousScanInReverseOrder()">
<h3>testPreviousScanInReverseOrder</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPreviousScanInReverseOrder</span>()</div>
<div class="block">Test del metodo <code>public Object previous()</code>: Testa che tutti gli elementi siano nello stesso ordine definito dalla lista.
 Partendo dalla fine e facendo una serie di chiamate successive a previous.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che ci sia corrispondenza tra gli elementi della lista e i valori ritornati dalle successive invocazioni
 di <code>previous()</code>.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando all'ultimo elemento. Iteratore
 creato.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore e' arrivato all'inizio della lista. La lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo iteratore e si testa che gli elementi ottenuti da <code>previous</code> siano gli stessi nella posizione i-esima della
 lista usando il metodo <code>get</code>. Si usa una variabile booleana isOk che viene settata a <code>false</code> se un'operazione di controllo
 ha un riscontro fallimentare.</dd>
<dt>Expected Results:</dt>
<dd>isOk deve essere <code>true</code>, ovvero l'ordine dato dall'iteratore deve essere esattamente quello della lista.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPreviousNextCorrectOrder()">
<h3>testPreviousNextCorrectOrder</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPreviousNextCorrectOrder</span>()</div>
<div class="block">Test del metodo <code>public Object previous()</code> e <code>public Object next()</code>: Testa che gli elementi vengano ritornati
 nell'ordine corretto scansionando la lista da inizio a fine e poi da fine a inizio.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che l'arrivo alla fine della lista in un verso non invalidi l'iteratore e renda scorretto lo scorrimento nel senso opposto
 subito successivo.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando all'ultimo elemento. Iteratore
 creato.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore e' tornato all'inizio della lista. La lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo iteratore e si testa che gli elementi ottenuti da <code>next</code> siano gli stessi nella posizione i-esima della
 lista usando il metodo <code>get</code>. Una volta arrivati alla fine della lista si fa la stessa operazione
 in senso contrario. Si usa una variabile booleana isOk che viene settata a <code>false</code> se un'operazione di controllo
 ha un riscontro fallimentare.</dd>
<dt>Expected Results:</dt>
<dd>isOk deve essere <code>true</code>, ovvero l'ordine dato dall'iteratore deve essere esattamente quello della lista.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPreviousGetSameElementAsNext()">
<h3>testPreviousGetSameElementAsNext</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPreviousGetSameElementAsNext</span>()</div>
<div class="block">Test del metodo <code>public Object previous()</code>: Si testa il comportamento di previous quando si va avanti di una posizione e poi si torna indietro.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Testo che andando avanti e indietro l'elemento scansionato in entrambi i casi deve essere lo stesso in quanto sono andato avanti e indietro di 1 posizione.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando al primo elemento. Iteratore
 creato.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore e' tornato alla prima posizione. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea un nuovo iteratore e lo si sposta avanti di una posizione usando il metodo next.
 Si torna poi indietro di una posizione invocando previous. Avendo scansionato lo stesso elemento, i valori ritornati
 da next e previous devono essere gli stessi.</dd>
<dt>Expected Results:</dt>
<dd>I due elementi sono uguali</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPreviousExceptionIfThereIsNotPrevious()">
<h3>testPreviousExceptionIfThereIsNotPrevious</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPreviousExceptionIfThereIsNotPrevious</span>()</div>
<div class="block">Test del metodo <code>public Object previous()</code>: testa che il metodo <code>previous</code> lanci eccezione
 <code>NoSuchElementException</code> nel caso in cui si provi ad ottenere un elemento con previous quando l'iteratore ha gia'
 raggiunto l'inizio della lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento e sollevamento dell'eccezione quando non ci sono elementi da restituire.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando a prima del primo elemento.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore non ha subito modifiche. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Siccome siamo all'inizio della lista, <code>it.hasNext()</code> ritorna <code>false</code>.
 Si prova ora ad ottenere un nuovo elemento. Tale operazione non puo' avere successo perche' la lista non ha altri elementi da ritornare.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>NoSuchElementException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveRemovesFromListAfterPrevious()">
<h3>testRemoveRemovesFromListAfterPrevious</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveRemovesFromListAfterPrevious</span>()</div>
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> rimuova l'elemento dalla lista appena
 restituito dal metodo previous.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento dell'iteratore quando si rimuove un elemento appena scansionato da previous.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando ad un elemento qualsiasi nella lista.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore si e' posizionato correttamente tra il precedente e il successivo dell'elemento rimosso.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore posizionato prima della posizione 2. Si invoca il metodo
 previous e si salva il valore ritornat in una variabile chiamata <code>removed</code>.
 Si invoca poi il metodo <code>remove</code>.
 L'elemento precedentemente salvato non deve piu' essere presente all'interno della lista. Si controlla cio' mediante il metodo contains() della lista.
 Siccome l'elemento e' stato ottenuto dal metodo next prima era sicuramente all'interno della lista.</dd>
<dt>Expected Results:</dt>
<dd><code>contains(removed)</code> deve ritornare <code>false</code>, l'elemento e' stato rimosso dalla lista.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPreviousWorksFineAfterRemove()">
<h3>testPreviousWorksFineAfterRemove</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPreviousWorksFineAfterRemove</span>()</div>
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lasci l'iteratore in uno stato corretto.
 Una volta rimosso l'elemento da una posizione, una successiva invocazione di previous deve ritornare quello precedente a quello che ora e' andato al posto
 dell'elemento rimosso dalla lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento dell'iteratore quando ci si sposta con previous dopo avere fatto una rimozione.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando ad un elemento qualsiasi nella lista.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore e' tornato all'inizio della lista.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si sposta tale iteratore di una posizione e si salva tale elemento
 in una variabile chiamata <code>expected</code>.
 Si rimuove poi il secondo elemento chiamando next e poi remove su di esso.
 Senza l'elemento nella seconda posizione, l'elemento che prima era nella terza posizione (2) va nella seconda posizione
 ma l'elemento nella posizione iniziale deve restare invariato.
 Un'invocazione di <code>previous</code> deve ritornare il primo elemento della lista (che e' rimasto invariato) salvato
 all'interno della variabile <code>expected</code>.</dd>
<dt>Expected Results:</dt>
<dd><code>previous</code> deve ritornare il valore contenuto in <code>expected</code> (il primo elemento della lista che non e' mai stato modificato).</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveThrowsExceptionAfterAdd()">
<h3>testRemoveThrowsExceptionAfterAdd</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveThrowsExceptionAfterAdd</span>()</div>
<div class="block">Test del metodo <code>public void remove()</code>: testa che il metodo <code>remove</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a chiamare il metodo <code>remove</code> subito dopo aver invocato il metodo <code>add</code>
 senza aver chiamato next.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento e sollevamento dell'eccezione quando l'iteratore non e' in uno stato valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore e' stato fatto avanzare di una posizione. E' stato inserito
 un elemento con il metodo add.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore non e' stato modificato. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si sposta in avanti l'iteratore usando next. Si prova ad inserire un elemento
 e subito dopo si esegue una rimozione.
 Tale rimozione non ha successo perche' prima non e' stato invocato il metodo next.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>IllegalStateException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddAtBeginning()">
<h3>testAddAtBeginning</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddAtBeginning</span>()</div>
<div class="block">Test del metodo <code>public void add(Object o)</code>: testa che il metodo add inserisca nella prima posizione della lista
 subito dopo aver creato l'iteratore.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Ci si assicura che l'inizializzazione dell'iteratore e' avvenuta correttamente e che il metodo add tratti gli indici
 nel modo corretto.</dd>
<dt>Pre-Condition:</dt>
<dd>lista creata e inizializzata con il metodo initialize. Iteratore creato e punta alla prima posizione della lista.</dd>
<dt>Post-Condition:</dt>
<dd>Un elemento e' stato inserito all'interno della lista. Gli indici dell'iteratore sono stati aggiornati opportunamente.</dd>
<dt>Test Description:</dt>
<dd>Si inserisce un elemento che precedentemente non era presente nella lista nella prima posizione. Una successiva
 invocazione di indexOf deve ritornare 0, ovvero l'indice da cui parte la lista.</dd>
<dt>Expected Results:</dt>
<dd><code>indexOf</code> ritorna 0.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddInMiddle()">
<h3>testAddInMiddle</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddInMiddle</span>()</div>
<div class="block">Test del metodo <code>public void add(Object o)</code>: testa che il metodo add inserisca correttamente in una posizione intermedia della
 lista. Si testa inoltre che e' stata inserita una sola occorrenza dell'elemento.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo add inserisca nella posizione corretta una sola volta l'oggetto passato.</dd>
<dt>Pre-Condition:</dt>
<dd>lista creata e inizializzata con il metodo initialize. Iteratore creato e punta ad una posizione successiva alla prima.</dd>
<dt>Post-Condition:</dt>
<dd>Un elemento e' stato inserito all'interno della lista. Gli indici dell'iteratore sono stati aggiornati opportunamente.</dd>
<dt>Test Description:</dt>
<dd>Ci si sposta avanti di una posizione con il metodo next per non puntare alla prima posizione della lista.
 Si inserisce un elemento che precedentemente non era presente nella lista con il metodo add. Una successiva
 invocazione di indexOf deve ritornare 1 perche' l'iteratore era avanzato di una sola posizione.
 Se gli indici ritornati da <code>indexOf</code> e <code>lastIndexOf</code> sono uguali, allora l'elemento inserito e' unico.</dd>
<dt>Expected Results:</dt>
<dd><code>indexOf</code> e <code>lastIndexOf</code> ritornano 1.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddAtEnd()">
<h3>testAddAtEnd</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddAtEnd</span>()</div>
<div class="block">Test del metodo <code>public void add(Object o)</code>: testa che il metodo add inserisca correttamente alla fine della
 lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo add inserisca nella posizione corretta in coda.</dd>
<dt>Pre-Condition:</dt>
<dd>lista creata e inizializzata con il metodo initialize. Iteratore creato e punta alla fine della lista.</dd>
<dt>Post-Condition:</dt>
<dd>Un elemento e' stato inserito all'interno della lista. Gli indici dell'iteratore sono stati aggiornati opportunamente.</dd>
<dt>Test Description:</dt>
<dd>Si crea un iteratore che punta all'ultima posizione della lista.
 Si inserisce un elemento che precedentemente non era presente nella lista con il metodo add. Una successiva
 invocazione di indexOf deve ritornare il valore della dimensione attuale della lista -1 perche' l'inserimento e' avvenuto in coda.</dd>
<dt>Expected Results:</dt>
<dd><code>indexOf</code> ritorna <code>list.size() - 1</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddInEmptyList()">
<h3>testAddInEmptyList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddInEmptyList</span>()</div>
<div class="block">Test del metodo <code>public void add(Object o)</code>: testa che il metodo add inserisca correttamente all'interno della lista
 se la lista e' vuota.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo add inserisca nella posizione corretta anche se nessun elemento e' presente nella lista.</dd>
<dt>Pre-Condition:</dt>
<dd>lista creata e inizializzata con il metodo initialize. Iteratore creato e punta all'inizio della lista.</dd>
<dt>Post-Condition:</dt>
<dd>Un elemento e' stato inserito all'interno della lista. Gli indici dell'iteratore sono stati aggiornati opportunamente.</dd>
<dt>Test Description:</dt>
<dd>Si svuota la lista. Si crea un iteratore che punta alla prima e ultima posizione della lista.
 Si inserisce un elemento nella lista con il metodo add. L'elemento appena inserito deve essere contenuto nella lista.
 Si testa cio' con il metodo contains</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddPreviousReturnElementJustInserted()">
<h3>testAddPreviousReturnElementJustInserted</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddPreviousReturnElementJustInserted</span>()</div>
<div class="block">Test del metodo <code>public void add(Object o)</code>: Testo che dopo una chiamata al metodo previous dopo l'inserimento ritorni
 l'elemento appena inserito. Verifico quindi che add lasci l'iteratore nella posizione corretta dopo aver effettuato l'inserimento.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo add lasci in uno stato corretto l'iteratore dopo aver effettuato l'inserimento.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore e' stato fatto avanzare di una posizione. E' stato inserito
 un elemento usando il metodo add.</dd>
<dt>Post-Condition:</dt>
<dd>E' stato inserito un elemento all'interno della lista.</dd>
<dt>Test Description:</dt>
<dd>Ci si sposta in una posizione centrale della lista per avere un precedente. Si inserisce poi un elemento in tale posizione.
 Successivamente si invoca previous per controllare qual e' il precedente
 La lista cambia nel seguente modo da prima a dopo l'inserimento: <pre>
 | 0 | 1 | 2 |    =====>        | 0 | 4 | 1 | 2 |
     ^                                   ^
    lit                                 lit
</pre></dd>
<dt>Expected Results:</dt>
<dd>Previous ritorna l'elemento appena inserito.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddNextReturnNextElement()">
<h3>testAddNextReturnNextElement</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddNextReturnNextElement</span>()</div>
<div class="block">Test del metodo <code>public void add(Object o)</code>: Testo che dopo una chiamata al metodo next dopo l'inserimento ritorni
 l'elemento successivo a quello appena inserito. Verifico quindi che add lasci l'iteratore nella posizione corretta dopo
 aver effettuato l'inserimento.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo add lasci in uno stato corretto l'iteratore dopo aver effettuato l'inserimento.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore e' stato fatto avanzare di una posizione. E' stato inserito
 un elemento usando il metodo add.</dd>
<dt>Post-Condition:</dt>
<dd>E' stato inserito un elemento all'interno della lista.</dd>
<dt>Test Description:</dt>
<dd>Ci si sposta in una posizione centrale della lista per avere un precedente.
 Vedo qual e' l'elemento presente dopo la posizione in cui andro' ad inserire usando next. Si torna indietro usando il metodo
 previous e poi si inserisce poi un elemento in tale posizione.
 Successivamente si invoca next per controllare qual e' il successivo, deve essere quello che si era ottenuto prima.
 La lista cambia nel seguente modo da prima a dopo l'inserimento: <pre>
 | 0 | 1 | 2 |    =====>        | 0 | 4 | 1 | 2 |
     ^                                   ^
    lit                                 lit
 </pre></dd>
<dt>Expected Results:</dt>
<dd>Next ritorna l'elemento successivo a quello appena inserito.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testNextIndexAtAnyPosition()">
<h3>testNextIndexAtAnyPosition</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testNextIndexAtAnyPosition</span>()</div>
<div class="block">Test del metodo <code>public int nextIndex()</code>: testa che il valore ritornato da nextIndex sia l'indice dell'elemento ritornato
 da una successiva chimata al metodo next.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>nextIndex() mostra lindice corretto delloggetto che sarebbe ritornato da una chiamata a next().</dd>
<dt>Pre-Condition:</dt>
<dd>lista inizializzata dal metodo initialize(). iteratore sta puntando all'elemento in prima posizione.</dd>
<dt>Post-Condition:</dt>
<dd>la lista non e' stata modificata, l'iteratore e' avanzato di una posizione</dd>
<dt>Test Description:</dt>
<dd>Si ottiene l'indice del successivo invocando il metodo nextIndex. Si invoca poi il metodo next e si cerca l'indice
 del valore da esso restituito all'interno della lista con il metodo indexOf.</dd>
<dt>Expected Results:</dt>
<dd>Gli indici ritornati devono essere uguali.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testNextIndexAtEndOfList()">
<h3>testNextIndexAtEndOfList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testNextIndexAtEndOfList</span>()</div>
<div class="block">Test del metodo <code>public int nextIndex()</code>: testa che se si e' alla fine della lista, il valore ritornato sia pari
 alla dimensione della lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>nextIndex() mostra lindice corretto delloggetto che sarebbe ritornato da una chiamata a next() o la dimensione della lista
 se si e' alla fine di essa.</dd>
<dt>Pre-Condition:</dt>
<dd>lista inizializzata dal metodo initialize(). iteratore sta puntando all'elemento in ultima posizione.</dd>
<dt>Post-Condition:</dt>
<dd>la lista non e' stata modificata, l'iteratore e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene l'indice del successivo invocando il metodo nextIndex. Siccome si e' alla fine della lista, il valore
 ritornato deve essere uguale alla dimensione della lista</dd>
<dt>Expected Results:</dt>
<dd><code>list.size()</code> e <code>nextIndex</code> devono ritornare lo stesso valore.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPreviousIndexInAnyPosition()">
<h3>testPreviousIndexInAnyPosition</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPreviousIndexInAnyPosition</span>()</div>
<div class="block">Test del metodo <code>public int previousIndex()</code>: testa che il valore ritornato da nextIndex sia l'indice dell'elemento ritornato
 da una successiva chimata al metodo previous.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>nextIndex() mostra lindice corretto delloggetto che sarebbe ritornato da una chiamata a previous().</dd>
<dt>Pre-Condition:</dt>
<dd>lista inizializzata dal metodo initialize(). L'iteratore ha letto il primo elemento.</dd>
<dt>Post-Condition:</dt>
<dd>la lista non e' stata modificata, l'iteratore e' retrocesso di una posizione</dd>
<dt>Test Description:</dt>
<dd>Si ottiene l'indice del successivo invocando il metodo previousIndex. Si invoca poi il metodo previous e si cerca l'indice
 del valore da esso restituito all'interno della lista con il metodo indexOf.</dd>
<dt>Expected Results:</dt>
<dd>Gli indici ritornati devono essere uguali.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testPreviousAtBeginningOfList()">
<h3>testPreviousAtBeginningOfList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testPreviousAtBeginningOfList</span>()</div>
<div class="block">Test del metodo <code>public int nextIndex()</code>: testa che se si e' alla fine della lista, il valore ritornato sia -1</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>nextIndex() mostra lindice corretto delloggetto che sarebbe ritornato da una chiamata a previous() o -1 se si e' all'inizio
 della lista stessa.</dd>
<dt>Pre-Condition:</dt>
<dd>lista inizializzata dal metodo initialize(). L'iteratore ha letto il primo elemento.</dd>
<dt>Post-Condition:</dt>
<dd>la lista non e' stata modificata, l'iteratore e' rimasto invariato.</dd>
<dt>Test Description:</dt>
<dd>Si ottiene l'indice del successivo invocando il metodo previousIndex. Siccome si e' all'inizio della lista, il valore
 ritornato deve essere -1.</dd>
<dt>Expected Results:</dt>
<dd><code>previousIndex</code> deve essere pari a -1.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testSetAfterNext()">
<h3>testSetAfterNext</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSetAfterNext</span>()</div>
<div class="block">Test del metodo <code>public Object set(Object o)</code>: testa che il metodo <code>set</code> sostituisca l'elemento ritornato dall'ultima
 invocazione del metodo next.
 Al termine dell'operazione l'elemento sostitutito non deve essere presente all'interno della lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo abbia rimosso l'elemento che e' appena stato sostituito.</dd>
<dt>Pre-Condition:</dt>
<dd>lista inizializzata dal metodo initialize(). Iteratore creato e ha appena letto l'elemento in prima posizione.</dd>
<dt>Post-Condition:</dt>
<dd>L'ultimo elemento ritornato da next e' stato sostituito.</dd>
<dt>Test Description:</dt>
<dd>Si salva l'elemento ritornato da una prima invocazione di next. Si invoca poi il metodo next per andare
 a sostituire l'elemento appena restituito con un oggetto diverso.
 L'elemento ritornato da next deve essere stato sostituito dall'elemento passato.
 Si controlla dunque che la lista non contenga piu' l'elemento usando il metodo contains.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testSetAfterPrevious()">
<h3>testSetAfterPrevious</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSetAfterPrevious</span>()</div>
<div class="block">Test del metodo <code>public Object set(Object o)</code>: testa che il metodo <code>set</code> sostituisca l'elemento ritornato dall'ultima
 invocazione del metodo previous.
 Al termine dell'operazione l'elemento sostitutito non deve essere presente all'interno della lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo abbia rimosso l'elemento che e' appena stato sostituito.</dd>
<dt>Pre-Condition:</dt>
<dd>lista inizializzata dal metodo initialize(). Iteratore creato e ha appena letto un elemento usando il metodo previous.</dd>
<dt>Post-Condition:</dt>
<dd>L'ultimo elemento ritornato da previous e' stato sostituito.</dd>
<dt>Test Description:</dt>
<dd>Si crea un iteratore che inizi dalla fine della lista. Si salva l'elemento ritornato da una prima invocazione di previous.
 Si invoca poi il metodo previous per andare a sostituire l'elemento appena restituito con un oggetto diverso.
 L'elemento ritornato da previous deve essere stato sostituito dall'elemento passato.
 Si controlla dunque che la lista non contenga piu' l'elemento usando il metodo contains.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>false</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testSetMultipleSet()">
<h3>testSetMultipleSet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSetMultipleSet</span>()</div>
<div class="block">Test del metodo <code>public void set(Object o)</code>: testa che il metodo <code>set</code> non lanci eccezione
 nel caso in cui si provi a settare 2 volte uno stesso elemento. Dopo una modifica l'iteratore continua ad essere valido.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento e sollevamento dell'eccezione quando l'iteratore non e' in uno stato valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore ha letto il primo elemento.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore e' ancora in uno stato valido. L'elemento letto da next e' stato modificato.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si ottiene un elemento con next che poi viene sostituito.
 Tale sostituizione ha successo perche' prima ho invocato il metodo next.
 Una successiva invocazione deve funzionare ancora perche' un set non invalida l'iteratore.
 Si controlla con il metodo contains che il secondo settaggio abbia avuto successo.</dd>
<dt>Expected Results:</dt>
<dd><code>contains</code> ritorna <code>true</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testSetExceptionAfterAdd()">
<h3>testSetExceptionAfterAdd</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSetExceptionAfterAdd</span>()</div>
<div class="block">Test del metodo <code>public void set()</code>: testa che il metodo <code>set</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a chiamare il metodo set subito dopo aver invocato il metodo add
 senza una precedente invocazione del metodo next o previous.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento e sollevamento dell'eccezione quando l'iteratore non e' in uno stato valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando al primo elemento. E' appena stato
 inserito un elemento all'interno della lista.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore non e' stato modificato. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si aggiunge un elemento nella prima posizione della lista.
 Una successiva invocazione del metodo set deve sollevare eccezione perche' non ho scansionato un ulteriore elemento dopo aver
 eseguito l'inserimento.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>IllegalStateException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testSetExceptionAfterRemove()">
<h3>testSetExceptionAfterRemove</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSetExceptionAfterRemove</span>()</div>
<div class="block">Test del metodo <code>public void set()</code>: testa che il metodo <code>set</code> lanci eccezione
 <code>IllegalStateException</code> nel caso in cui si provi a chiamare il metodo set subito dopo aver invocato il metodo remove
 senza una precedente invocazione del metodo next o previous.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento e sollevamento dell'eccezione quando l'iteratore non e' in uno stato valido.</dd>
<dt>Pre-Condition:</dt>
<dd>Oggetto ListAdapter inizializzato dal metodo initialize(). L'iteratore sta puntando al primo elemento. E' appena stato
 rimosso un elemento dalla lista.</dd>
<dt>Post-Condition:</dt>
<dd>L'iteratore non e' stato modificato. La lista non ha subito modifiche.</dd>
<dt>Test Description:</dt>
<dd>Si crea una lista e il suo rispettivo iteratore. Si scansiona un elemento con next che poi viene rimosso.
 Una successiva invocazione del metodo set deve sollevare eccezione perche' non ho scansionato un ulteriore elemento dopo aver
 eseguito la cancellazione.</dd>
<dt>Expected Results:</dt>
<dd>L'eccezione <code>IllegalStateException</code> deve essere lanciata. Si controlla con il metodo <code>assertThrows()</code> fornito
 dal framework JUnit.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
