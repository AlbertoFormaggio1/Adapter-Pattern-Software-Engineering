<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (15) on Fri May 14 13:46:40 CEST 2021 -->
<title>SubListTester</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-05-14">
<meta name="description" content="declaration: package: myTest, class: SubListTester">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">myTest</a></div>
<h1 title="Class SubListTester" class="title">Class SubListTester</h1>
</div>
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">myTest.SubListTester</div>
</div>
<section class="description">
<hr>
<pre>public class <span class="type-name-label">SubListTester</span>
extends java.lang.Object</pre>
<div class="block">Questa suite di test ha il compito di testare che la sottolista di un oggetto <code>ListAdapter</code> abbia una corretta
 visione della lista padre. Si verifica inoltre la proprieta' di backing su questa sottolista per cui modifiche strutturali
 e non strutturali devono avere ripercussioni sulla lista originale. Modifiche non strutturali alla lista padre devono avere
 ripercussioni nella sottolista.<p>
 Si vuole dimostrare che tutti i metodi definiti in <code>SubList</code> funzionino correttamente</div>
<dl class="notes">
<dt>Author:</dt>
<dd>Formaggio Alberto</dd>
<dt>See Also:</dt>
<dd><a href="ListAdapterTester.html" title="class in myTest"><code>ListAdapterTester</code></a>, 
<a href="ListIteratorTester.html" title="class in myTest"><code>ListIteratorTester</code></a></dd>
<dt><b>Test Suite Design:</b></dt>
<dd>Per testare la classe nella sua interezza e' stato testato ciascun metodo fornendo in input parametri validi
 e non validi in modo da testare il piu' ampio numero di casi possibili in cui la sottolista si puo' trovare.<p>
 La documentazione di ciascun test case e' stata eseguita seguendo la colonna "homework" fornita nel file della consegna,
 inoltre i metodi hanno tutti un nome che e' il piu' evocativo possibile.</dd>
<dt><b>Pre-Condition:</b></dt>
<dd>Si assicura che i metodi definiti nella classe <code>ListAdapter</code> siano gia' stati testati.
 Per tale motivo verranno testati i metodi ridefiniti in <code>SubList</code> e quelli che dipendono direttamente dagli indici from e to che
 definiscono la porzione di lista visibile. Tutti gli altri se funzionano per <code>ListAdapter</code> funzioneranno sicuramente anche per
 <code>SubList</code>.</dd>
<dt><b>Post-Condition:</b></dt>
<dd>Si sono ottenuti i risultati dell'esecuzione di tutti i test in questa suite.</dd>
<dt>Test Suite Execution Records:</dt>
<dd>Consultare il file <a href="..\..\Test suite execution records\Test Results - SubListTester.html">
     "Test Results - SubListTester.html"</a> nella cartella "Test suite execution records"</dd>
<dt>Execution Variables:</dt>
<dd>I test sono stati eseguiti utilizzando JUnit v4.13 e hamcrest v1.3.
 Per poter lanciare i test e' necessario inserire i file .jar di questi framework all'interno del CLASSPATH settando tale
 variabile di ambiente.</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>private int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#fromIndex">fromIndex</a></span></code></th>
<td class="col-last">
<div class="block">Indice iniziale (incluso) della lista padre visibile dalla sottolista.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>private <a href="../myAdapter/ListAdapter.html" title="class in myAdapter">ListAdapter</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#list">list</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>private <a href="../myAdapter/HList.html" title="interface in myAdapter">HList</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#sub">sub</a></span></code></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>private int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toIndex">toIndex</a></span></code></th>
<td class="col-last">
<div class="block">Indice finale (escluso) della lista padre visibile dalla sottolista.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor.summary">
<h2>Constructor Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Constructors</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Constructor</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<th class="col-constructor-name" scope="row"><code><span class="member-name-link"><a href="#%3Cinit%3E()">SubListTester</a></span>()</code></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="table-tab" onclick="show(8);">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#Initialize()">Initialize</a></span>()</code></th>
<td class="col-last">
<div class="block">Inizializza un oggetto inserendo 3 valori in ordine 0,1,2.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddIndexAtBeginningBacking()">testAddIndexAtBeginningBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean add(int index, Object o)</code>: Testo che se un elemento viene inserito nella sottolista, questo venga
 inserito anche nella lista principale nella posizione corretta.</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddIndexAtEnd()">testAddIndexAtEnd</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean add(int index, Object o)</code>: Testo che se un elemento viene inserito nella sottolista, questo venga
 inserito anche nella lista principale nella posizione corretta.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddIndexInMiddleBacking()">testAddIndexInMiddleBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean add(int index, Object o)</code>: Testo che se un elemento viene inserito nella sottolista, questo venga
 inserito anche nella lista principale nella posizione corretta.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddRecursiveSubListContains()">testAddRecursiveSubListContains</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean add(Object o)</code>: Testo che l'add su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddRecursiveSubListGet()">testAddRecursiveSubListGet</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean add(Object o)</code>: Testo che l'add su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testAddRecursiveSubListSize()">testAddRecursiveSubListSize</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean add(Object o)</code>: Testo che l'add su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsFalseIfOnlyInParentListAfter()">testContainsFalseIfOnlyInParentListAfter</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi al suo interno, gli elementi
 NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre non risultino presenti nella sottolista.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsFalseIfOnlyInParentListBefore()">testContainsFalseIfOnlyInParentListBefore</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi al suo interno, gli elementi
 NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre non risultino presenti nella sottolista.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testContainsTrueIfPresent()">testContainsTrueIfPresent</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi al suo interno, gli elementi
 presenti nella porzione di lista a lei visibile siano presenti all'interno della sottolista stessa.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testGetReturnsRightElementInSublist()">testGetReturnsRightElementInSublist</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public Object get(int index)</code>: testa che il metodo <code>get</code> ritorni correttamente l'elemento
 associato all'indice passato anche quando si considera una sottolista.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testIndexOfWithElementInParentListAfter()">testIndexOfWithElementInParentListAfter</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int indexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, gli elementi NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre NON vengano trovati quando
 si prova ad invocare il metodo indexOf nella sottolista.</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testIndexOfWithElementInParentListBefore()">testIndexOfWithElementInParentListBefore</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int indexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, gli elementi NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre NON vengano trovati quando
 si prova ad invocare il metodo indexOf nella sottolista.</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testIndexOfWithElementInSubList()">testIndexOfWithElementInSubList</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int indexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, conoscendo la disposizione degli elementi all'interno della stessa, questa disposizione sia coerente con quanto ritornato
 dal metodo indexOf().</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testIsEmptyFalseIfIndexesAreNotTheSame()">testIsEmptyFalseIfIndexesAreNotTheSame</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean isEmpty()</code>: Testo che appena creata una sottolista se gli indici from e to non sono uguali, questa non risulti vuota.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testIsEmptyTrueIfIndexesAreTheSame()">testIsEmptyTrueIfIndexesAreTheSame</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean isEmpty()</code>: Testo che appena creata una sottolista se gli indici from e to sono uguali, questa risulti vuota.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testLastIndexOfWithElementInParentListAfter()">testLastIndexOfWithElementInParentListAfter</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int lastIndexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, gli elementi NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre NON vengano trovati quando
 si prova ad invocare il metodo lastIndexOf nella sottolista.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testLastIndexOfWithElementInParentListBefore()">testLastIndexOfWithElementInParentListBefore</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int lastIndexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, gli elementi NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre NON vengano trovati quando
 si prova ad invocare il metodo lastIndexOf nella sottolista.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testLastIndexOfWithElementInSubList()">testLastIndexOfWithElementInSubList</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int lastIndexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, conoscendo la disposizione degli elementi all'interno della stessa, questa disposizione sia coerente con quanto ritornato
 dal metodo lastIndexOf().</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveFailsInSublist()">testRemoveFailsInSublist</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: Testo che se si prova a rimuovere un elemento dalla sottolista
 che non e' presente nella lista principale, la rimozione non abbia successo.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveRecursiveSubListContains()">testRemoveRecursiveSubListContains</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: Testo che il remove su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveRecursiveSubListSize()">testRemoveRecursiveSubListSize</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: Testo che il remove su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti.</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testRemoveSucceedsWithBacking()">testRemoveSucceedsWithBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: Testo che se un elemento viene rimosso dalla sottolista, questo venga rimosso
 anche dalla lista principale.</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSetSucceedsWithBacking()">testSetSucceedsWithBacking</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void set(int index, Object o)</code>: Testo che se un elemento viene modificato nella sottolista, questo venga
 modificato anche nella lista principale nella posizione corretta.</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSizeIsRight()">testSizeIsRight</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public int size()</code>: Testo che dopo l'inizializzazione la sottolista abbia dimensione
 pari alla differenza degli indici to e from.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSubListClear()">testSubListClear</a></span>()</code></th>
<td class="col-last">
<div class="block">Test del metodo <code>public void clear()</code>: testo che facendo il clear della lista figlia, nella lista padre siano stati
 cancellati SOLO gli elementi presenti all'interno della sottolista.</div>
</td>
</tr>
<tr class="alt-color" id="i26">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#testSubListElementCorrespondenceWithParent()">testSubListElementCorrespondenceWithParent</a></span>()</code></th>
<td class="col-last">
<div class="block">Test dell'inizializzazione di subList: testo che gli elementi abbiano una corrispondenza con la lista che l'ha generata.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inherited-list">
<h3 id="methods.inherited.from.class.java.lang.Object">Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="list">
<h3>list</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/ListAdapter.html" title="class in myAdapter">ListAdapter</a></span>&nbsp;<span class="member-name">list</span></div>
</section>
</li>
<li>
<section class="detail" id="sub">
<h3>sub</h3>
<div class="member-signature"><span class="modifiers">private</span>&nbsp;<span class="return-type"><a href="../myAdapter/HList.html" title="interface in myAdapter">HList</a></span>&nbsp;<span class="member-name">sub</span></div>
</section>
</li>
<li>
<section class="detail" id="fromIndex">
<h3>fromIndex</h3>
<div class="member-signature"><span class="modifiers">private final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">fromIndex</span></div>
<div class="block">Indice iniziale (incluso) della lista padre visibile dalla sottolista.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="../constant-values.html#myTest.SubListTester.fromIndex">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toIndex">
<h3>toIndex</h3>
<div class="member-signature"><span class="modifiers">private final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">toIndex</span></div>
<div class="block">Indice finale (escluso) della lista padre visibile dalla sottolista.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="../constant-values.html#myTest.SubListTester.toIndex">Constant Field Values</a></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor.detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>SubListTester</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="member-name">SubListTester</span>()</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="Initialize()">
<h3>Initialize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">Initialize</span>()</div>
<div class="block">Inizializza un oggetto inserendo 3 valori in ordine 0,1,2. Al termine della creazione la lista su cui verrano eseguiti i test sara'
 fatta nel seguente modo:
<pre>
 list
 | 0 | 1 | 2 | 3 | 4 |
</pre>
 Crea inoltre una subList che va da 1 (incluso) a 4 (escluso), ovvero la sublist sara' fatta nel seguente modo:<pre>
 | 1 | 2 | 3 |
 </pre></div>
</section>
</li>
<li>
<section class="detail" id="testSizeIsRight()">
<h3>testSizeIsRight</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSizeIsRight</span>()</div>
<div class="block">Test del metodo <code>public int size()</code>: Testo che dopo l'inizializzazione la sottolista abbia dimensione
 pari alla differenza degli indici to e from.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Testo che la dimensione dopo l'inizializzazione sia corretta.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista  create dal metodo initialize</dd>
<dt>Post-Condition:</dt>
<dd>la sottolista non e' stata modificata.</dd>
<dt>Test Description:</dt>
<dd>creo una nuova lista e una sua sottolista che va dalla posizione 1 inclusa alla posizione 4 esclusa.
 La dimensione deve essere 3 perche' 4 - 1 = 3.</dd>
<dt>Expected Results:</dt>
<dd>La lista ha dimensione 3.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testSubListElementCorrespondenceWithParent()">
<h3>testSubListElementCorrespondenceWithParent</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSubListElementCorrespondenceWithParent</span>()</div>
<div class="block">Test dell'inizializzazione di subList: testo che gli elementi abbiano una corrispondenza con la lista che l'ha generata.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che gli indici della sottolista siano corretti rispetto alla lista principale.
 Ad esempio sub = list.subList(1,4). Crea la seguente lista:
 sub: | 1 | 2 | 3 |.
 L'elemento che sub ha in posizione 0 deve essere in posizione 1 nella lista principale (perche' la sottolista inizia dalla posizione 1)
 L'elemento che sub ha in posizione 1 deve essere in posizione 2 nella lista principale
 L'elemento che sub ha in posizione 2 deve essere in posizione 3 nella lista principale
 Cioe' la posizione nella lista e' data da (posizioneInizialeSottolista) + (offsetSottolista)</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize</dd>
<dt>Post-Condition:</dt>
<dd>Lista e sottolista sono rimaste invariate.</dd>
<dt>Test Description:</dt>
<dd>Una volta creata lista e sottolista che parte dalla posizione 1, si inizia a scansionare la lista.
 L'elemento in posizione i-esima della sottolista deve essere nella posizione i+1 (perche' la sottolista parte da 1).</dd>
<dt>Expected Results:</dt>
<dd>Le posizione tra elementi della sottolista e lista principale corrispondono.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testSubListClear()">
<h3>testSubListClear</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSubListClear</span>()</div>
<div class="block">Test del metodo <code>public void clear()</code>: testo che facendo il clear della lista figlia, nella lista padre siano stati
 cancellati SOLO gli elementi presenti all'interno della sottolista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che clear cancelli gli elementi della sottolista dalla lista principale e non altri elementi.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista create dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La sottolista e' vuota</dd>
<dt>Test Description:</dt>
<dd>Ottengo la dimensione della lista prima della rimozione e quella della sottolista.
 Dopo l'invocazione di clear la dimensione deve essere diminuita di una quantita' pari alla dimensione della sottolista.
 Il metodo size e' usato per fare il controllo</dd>
<dt>Expected Results:</dt>
<dd>La dimensione della lista dopo la rimozione e' dimListaPrimaRimozione - dimSottolistaPrimaRimozione.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testIsEmptyTrueIfIndexesAreTheSame()">
<h3>testIsEmptyTrueIfIndexesAreTheSame</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testIsEmptyTrueIfIndexesAreTheSame</span>()</div>
<div class="block">Test del metodo <code>public boolean isEmpty()</code>: Testo che appena creata una sottolista se gli indici from e to sono uguali, questa risulti vuota.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Testo che il metodo isEmpty() ritorni true quando la lista e' stata inizializzata per essere sicuro che quando gli indici passati sono uguali
 la lista risulti vuota.</dd>
<dt>Pre-Condition:</dt>
<dd>e' stata creata una lista dal metodo initialize(). Sottolista creata con indici validi uguali tra loro.</dd>
<dt>Post-Condition:</dt>
<dd>la lista e la sottolista sono rimaste invariate.</dd>
<dt>Test Description:</dt>
<dd>Creo una nuova lista che va dalla posizione 1 inclusa alla posizione 1 esclusa, non deve quindi contenere nessun elemento.
 Dopo averla creata controllo che la lista sia vuota invocando il metodo isEmpty().</dd>
<dt>Expected Results:</dt>
<dd><code>isEmpty</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testIsEmptyFalseIfIndexesAreNotTheSame()">
<h3>testIsEmptyFalseIfIndexesAreNotTheSame</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testIsEmptyFalseIfIndexesAreNotTheSame</span>()</div>
<div class="block">Test del metodo <code>public boolean isEmpty()</code>: Testo che appena creata una sottolista se gli indici from e to non sono uguali, questa non risulti vuota.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Testo che il metodo isEmpty() ritorni false quando la lista e' stata inizializzata per essere sicuro che quando gli indici passati non sono uguali
 la lista non risulti vuota.</dd>
<dt>Pre-Condition:</dt>
<dd>e' stata creata una lista e una sottolista dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>la lista e la sottolista sono rimaste invariate.</dd>
<dt>Test Description:</dt>
<dd>Creo una nuova lista che va dalla posizione 1 inclusa alla posizione 4 esclusa, deve quindi contenere degli elementi.
 Dopo averla creata controllo che la lista non sia vuota invocando il metodo isEmpty().</dd>
<dt>Expected Results:</dt>
<dd><code>isEmpty</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddIndexAtBeginningBacking()">
<h3>testAddIndexAtBeginningBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddIndexAtBeginningBacking</span>()</div>
<div class="block">Test del metodo <code>public boolean add(int index, Object o)</code>: Testo che se un elemento viene inserito nella sottolista, questo venga
 inserito anche nella lista principale nella posizione corretta.
 L'inserimento avviene nella prima posizione della sottolista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento della proprieta' di backing quando si esegue un add nella sottolista.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inzializzte dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato inserito un elemento sia nella lista padre che nella sottolista.</dd>
<dt>Test Description:</dt>
<dd>Si inserisce un elemento non presente nella sottolista usando il metodo add.
 L'elemento inserito nella sottolista e' in posizione 0, quindi in posizione 1 nella lista principale.
 Si invoca il metodo get nella posizione 1 della lista principale per verificare che il l'add abbia avuto successo.</dd>
<dt>Expected Results:</dt>
<dd><code>list.get(1)</code> deve ritornare l'elemento appena inserito da add</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddIndexInMiddleBacking()">
<h3>testAddIndexInMiddleBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddIndexInMiddleBacking</span>()</div>
<div class="block">Test del metodo <code>public boolean add(int index, Object o)</code>: Testo che se un elemento viene inserito nella sottolista, questo venga
 inserito anche nella lista principale nella posizione corretta.
 L'inserimento avviene in una posizione intermedia della sottolista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento della proprieta' di backing quando si esegue un add nella sottolista.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inzializzte dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato inserito un elemento sia nella lista padre che nella sottolista.</dd>
<dt>Test Description:</dt>
<dd>Si inserisce un elemento non presente nella sottolista usando il metodo add.
 L'elemento inserito nella sottolista e' in posizione 1, quindi in posizione 2 nella lista principale.
 Si invoca il metodo get nella posizione 2 della lista principale per verificare che il l'add abbia avuto successo.</dd>
<dt>Expected Results:</dt>
<dd><code>list.get(2)</code> deve ritornare l'elemento appena inserito da add</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddIndexAtEnd()">
<h3>testAddIndexAtEnd</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddIndexAtEnd</span>()</div>
<div class="block">Test del metodo <code>public boolean add(int index, Object o)</code>: Testo che se un elemento viene inserito nella sottolista, questo venga
 inserito anche nella lista principale nella posizione corretta.
 L'inserimento avviene nell'ultima posizione della sottolista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento della proprieta' di backing quando si esegue un add nella sottolista. Siccome un add con l'indice uguale alla size e'
 la stessa cosa di un add senza indice, uso l'add senza indice. Il risultato deve essere il medesimo.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inzializzte dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato inserito un elemento sia nella lista padre che nella sottolista.</dd>
<dt>Test Description:</dt>
<dd>Si inserisce un elemento non presente nella sottolista usando il metodo add.
 L'elemento inserito nella sottolista e' in posizione sub.size() = 3, quindi in posizione 4 nella lista principale.
 Si invoca il metodo get nella posizione 4 della lista principale per verificare che il l'add abbia avuto successo.</dd>
<dt>Expected Results:</dt>
<dd><code>list.get(4)</code> deve ritornare l'elemento appena inserito da add</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsFalseIfOnlyInParentListBefore()">
<h3>testContainsFalseIfOnlyInParentListBefore</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsFalseIfOnlyInParentListBefore</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi al suo interno, gli elementi
 NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre non risultino presenti nella sottolista.
 Si testa cio' con un elemento collocato PRIMA dell'inizio di questa lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che determinati oggetti presenti nella lista ma NON nella sottolista NON risultino presenti nella sottolista.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e la sottolista sono rimaste invariate.</dd>
<dt>Test Description:</dt>
<dd>cerco l'elemento 0 precedentemente inserito dal metodo initialize() usando il metodo contains(). Siccome la sottolista NON vede
 la cella in posizione 0 della lista originale (contenente l'elemento 0) e la lista originale non e' stata modificata, l'elemento non e' presente nella
 sottolista ma nella lista padre.
 0 nella lista originale si trova a sinistra della sottolista.</dd>
<dt>Expected Results:</dt>
<dd><code>contains(0)</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsFalseIfOnlyInParentListAfter()">
<h3>testContainsFalseIfOnlyInParentListAfter</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsFalseIfOnlyInParentListAfter</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi al suo interno, gli elementi
 NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre non risultino presenti nella sottolista.
 Si testa cio' con un elemento collocato DOPO la fine di questa lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che determinati oggetti presenti nella lista ma NON nella sottolista NON risultino presenti nella sottolista.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e la sottolista sono rimaste invariate.</dd>
<dt>Test Description:</dt>
<dd>cerco l'elemento 4 precedentemente inserito dal metodo initialize() usando il metodo contains(). Siccome la sottolista NON vede
 la cella in posizione 4 della lista originale (contenente l'elemento 4) e la lista originale non e' stata modificata, l'elemento non e' presente nella
 sottolista ma nella lista padre.
 4 nella lista originale si trova a destra della sottolista.</dd>
<dt>Expected Results:</dt>
<dd><code>contains(4)</code> ritorna <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testContainsTrueIfPresent()">
<h3>testContainsTrueIfPresent</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testContainsTrueIfPresent</span>()</div>
<div class="block">Test del metodo <code>public boolean contains(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi al suo interno, gli elementi
 presenti nella porzione di lista a lei visibile siano presenti all'interno della sottolista stessa.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che determinati oggetti presenti nella lista e nella sottolista risultino presenti nella sottolista.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>cerco l'elemento 2 precedentemente inserito dal metodo initialize() usando il metodo contains(). Siccome la sottolista vede
 la cella in posizione 2 della lista originale (contenente l'elemento 2) e la lista originale non e' stata modificata, l'elemento e' presente sia nella
 sottolista che nella lista padre.</dd>
<dt>Expected Results:</dt>
<dd>contains(2) ritorna true</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testIndexOfWithElementInSubList()">
<h3>testIndexOfWithElementInSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testIndexOfWithElementInSubList</span>()</div>
<div class="block">Test del metodo <code>public int indexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, conoscendo la disposizione degli elementi all'interno della stessa, questa disposizione sia coerente con quanto ritornato
 dal metodo indexOf().</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo indexOf() ritorni la posizione corretta dell'oggetto quando questo e' presente nella sottolista.
 Gli indici utilizzati all'interno del metodo indexOf devono essere corretti anche nel caso generale dove from != 0 e to != size().</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Creo una sottolista che va dagli indici 1 incluso al 4 escluso.
 La sottolista dopo la creazione e' fatta nel segunente modo: | 1 | 2 | 3 |.
 Cercando l'elemento 1, essendo questo presente all'interno della sottolista, devo ottenere l'indice 0 che corrisponde alla prima posizione
 della sottolista (e la seconda della lista padre). Tale ricerca viene fatta usando il metodo <code>indexOf</code></dd>
<dt>Expected Results:</dt>
<dd><code>indexOf(1)</code> ritorna 0.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testIndexOfWithElementInParentListBefore()">
<h3>testIndexOfWithElementInParentListBefore</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testIndexOfWithElementInParentListBefore</span>()</div>
<div class="block">Test del metodo <code>public int indexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, gli elementi NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre NON vengano trovati quando
 si prova ad invocare il metodo indexOf nella sottolista.
 Si testa cio' con un elemento collocato PRIMA dell'inizio di questa lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo indexOf() ritorni -1 se questo e' presente nella lista padre ma non in questa lista. Gli indici utilizzati
 all'interno del metodo indexOf devono essere corretti anche nel caso generale dove from != 0 e to != size().</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Creo una sottolista che va dagli indici 1 incluso al 4 escluso.
 La sottolista dopo la creazione e' fatta nel segunente modo: | 1 | 2 | 3 |.
 Cercando l'elemento 0, essendo questo non presente all'interno della sottolista ma solo all'interno della lista padre,
 devo ottenere l'indice -1 che corrisponde ad un elemento non trovato. Tale ricerca viene fatta usando il metodo <code>indexOf</code></dd>
<dt>Expected Results:</dt>
<dd><code>indexOf(0)</code> ritorna -1.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testIndexOfWithElementInParentListAfter()">
<h3>testIndexOfWithElementInParentListAfter</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testIndexOfWithElementInParentListAfter</span>()</div>
<div class="block">Test del metodo <code>public int indexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, gli elementi NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre NON vengano trovati quando
 si prova ad invocare il metodo indexOf nella sottolista.
 Si testa cio' con un elemento collocato DOPO dell'inizio di questa lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo indexOf() ritorni -1 se questo e' presente nella lista padre ma non in questa lista. Gli indici utilizzati
 all'interno del metodo indexOf devono essere corretti anche nel caso generale dove from != 0 e to != size().</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Creo una sottolista che va dagli indici 1 incluso al 4 escluso.
 La sottolista dopo la creazione e' fatta nel segunente modo: | 1 | 2 | 3 |.
 Cercando l'elemento 4, essendo questo non presente all'interno della sottolista ma solo all'interno della lista padre,
 devo ottenere l'indice -1 che corrisponde ad un elemento non trovato. Tale ricerca viene fatta usando il metodo <code>indexOf</code></dd>
<dt>Expected Results:</dt>
<dd><code>indexOf(4)</code> ritorna -1.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testLastIndexOfWithElementInSubList()">
<h3>testLastIndexOfWithElementInSubList</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testLastIndexOfWithElementInSubList</span>()</div>
<div class="block">Test del metodo <code>public int lastIndexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, conoscendo la disposizione degli elementi all'interno della stessa, questa disposizione sia coerente con quanto ritornato
 dal metodo lastIndexOf().</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo lastIndexOf() ritorni la posizione corretta dell'oggetto quando questo e' presente nella sottolista.
 Gli indici utilizzati all'interno del metodo lastIndexOf devono essere corretti anche nel caso generale dove from != 0 e to != size().</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Creo una sottolista che va dagli indici 1 incluso al 4 escluso.
 La sottolista dopo la creazione e' fatta nel segunente modo: | 1 | 2 | 3 |.
 Cercando l'elemento 1, essendo questo presente all'interno della sottolista, devo ottenere l'indice 0 che corrisponde alla prima posizione
 della sottolista (e la seconda della lista padre). Tale ricerca viene fatta usando il metodo <code>lastIndexOf</code></dd>
<dt>Expected Results:</dt>
<dd><code>lastIndexOf(1)</code> ritorna 0.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testLastIndexOfWithElementInParentListBefore()">
<h3>testLastIndexOfWithElementInParentListBefore</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testLastIndexOfWithElementInParentListBefore</span>()</div>
<div class="block">Test del metodo <code>public int lastIndexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, gli elementi NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre NON vengano trovati quando
 si prova ad invocare il metodo lastIndexOf nella sottolista.
 Si testa cio' con un elemento collocato PRIMA dell'inizio di questa lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo lastIndexOf() ritorni -1 se questo e' presente nella lista padre ma non in questa lista. Gli indici utilizzati
 all'interno del metodo lastIndexOf devono essere corretti anche nel caso generale dove from != 0 e to != size().</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Creo una sottolista che va dagli indici 1 incluso al 4 escluso.
 La sottolista dopo la creazione e' fatta nel segunente modo: | 1 | 2 | 3 |.
 Cercando l'elemento 0, essendo questo non presente all'interno della sottolista ma solo all'interno della lista padre,
 devo ottenere l'indice -1 che corrisponde ad un elemento non trovato. Tale ricerca viene fatta usando il metodo <code>lastIndexOf</code></dd>
<dt>Expected Results:</dt>
<dd><code>lastIndexOf(0)</code> ritorna -1.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testLastIndexOfWithElementInParentListAfter()">
<h3>testLastIndexOfWithElementInParentListAfter</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testLastIndexOfWithElementInParentListAfter</span>()</div>
<div class="block">Test del metodo <code>public int lastIndexOf(Object o)</code>: Testo che, una volta inizializzata la sottolista con degli elementi
 al suo interno, gli elementi NON presenti nella porzione di lista a lei visibile ma presenti nella lista padre NON vengano trovati quando
 si prova ad invocare il metodo lastIndexOf nella sottolista.
 Si testa cio' con un elemento collocato DOPO dell'inizio di questa lista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che il metodo lastIndexOf() ritorni -1 se questo e' presente nella lista padre ma non in questa lista. Gli indici utilizzati
 all'interno del metodo lastIndexOf devono essere corretti anche nel caso generale dove from != 0 e to != size().</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inizializzate dal metodo initialize().</dd>
<dt>Post-Condition:</dt>
<dd>la lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Creo una sottolista che va dagli indici 1 incluso al 4 escluso.
 La sottolista dopo la creazione e' fatta nel segunente modo: | 1 | 2 | 3 |.
 Cercando l'elemento 4, essendo questo non presente all'interno della sottolista ma solo all'interno della lista padre,
 devo ottenere l'indice -1 che corrisponde ad un elemento non trovato. Tale ricerca viene fatta usando il metodo <code>lastIndexOf</code></dd>
<dt>Expected Results:</dt>
<dd><code>lastIndexOf(4)</code> ritorna -1.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testGetReturnsRightElementInSublist()">
<h3>testGetReturnsRightElementInSublist</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testGetReturnsRightElementInSublist</span>()</div>
<div class="block">Test del metodo <code>public Object get(int index)</code>: testa che il metodo <code>get</code> ritorni correttamente l'elemento
 associato all'indice passato anche quando si considera una sottolista.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto valore di ritorno del metodo <code>get</code> quando questo viene invocato in una sottolista.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista inizializzata con il metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La lista e' rimasta invariata.</dd>
<dt>Test Description:</dt>
<dd>Si prova ad ottenere un elemento nella posizione 1. Per come e' stata inizializzata la sottolista, nella posizione 1
 e' presente l'elemento 2.</dd>
<dt>Expected Results:</dt>
<dd><code>get</code> ritorna 2.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveSucceedsWithBacking()">
<h3>testRemoveSucceedsWithBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveSucceedsWithBacking</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: Testo che se un elemento viene rimosso dalla sottolista, questo venga rimosso
 anche dalla lista principale.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento della proprieta' di backing quando si esegue il remove dalla sottolista.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inzializzte dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato rimosso un elemento sia dalla lista padre che dalla sottolista.</dd>
<dt>Test Description:</dt>
<dd>Si rimuove un elemento presente nella sottolista (2) usando il metodo remove. Siccome 2 e' presente nella sottolista
 la rimozione ha successo e il metodo remove deve ritornare true.
 La lista principale non deve contenere l'elemento appena rimosso. Si fa il test usando il metodo contains()</dd>
<dt>Expected Results:</dt>
<dd><code>list.contains(2)</code> deve ritornare <code>false</code> perche' l'elemento e' stato rimosso</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveFailsInSublist()">
<h3>testRemoveFailsInSublist</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveFailsInSublist</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: Testo che se si prova a rimuovere un elemento dalla sottolista
 che non e' presente nella lista principale, la rimozione non abbia successo.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento che nell'operazione di remove la sottolista veda solo i suoi elementi e non quelli della lista padre.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inzializzte dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>La sottolista e la lista sono rimaste invariate.</dd>
<dt>Test Description:</dt>
<dd>Si prova a rimuovere un elemento presente nella lista che non e' presente nella sottolista (4) usando il metodo remove.
 Siccome 4 non e' presente nella sottolista la rimozione non ha successo e il metodo remove deve ritornare false.
 La lista principale continua a contenere l'elemento rimosso. Si fa il test usando il metodo contains()</dd>
<dt>Expected Results:</dt>
<dd><code>list.contains(4)</code> deve ritornare <code>true</code> perche' l'elemento non e' stato rimosso.
 <code>remove</code> invocato sulla sottolista deve ritornare <code>false</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testSetSucceedsWithBacking()">
<h3>testSetSucceedsWithBacking</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testSetSucceedsWithBacking</span>()</div>
<div class="block">Test del metodo <code>public void set(int index, Object o)</code>: Testo che se un elemento viene modificato nella sottolista, questo venga
 modificato anche nella lista principale nella posizione corretta.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento della proprieta' di backing quando si esegue il set nella sottolista.</dd>
<dt>Pre-Condition:</dt>
<dd>Lista e sottolista inzializzte dal metodo initialize()</dd>
<dt>Post-Condition:</dt>
<dd>E' stato sostituito un elemento sia dalla lista padre che dalla sottolista.</dd>
<dt>Test Description:</dt>
<dd>Si sostituisce un elemento presente nella sottolista usando il metodo set.
 L'elemento sostituito nella sottolista e' in posizione 2, quindi in posizione 3 nella lista principale.
 Si invoca il metodo get nella posizione 3 della lista principale per verificare che il set abbia avuto successo.</dd>
<dt>Expected Results:</dt>
<dd><code>get(3)</code> deve ritornare l'elemento appena inserito da set</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddRecursiveSubListSize()">
<h3>testAddRecursiveSubListSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddRecursiveSubListSize</span>()</div>
<div class="block">Test del metodo <code>public boolean add(Object o)</code>: Testo che l'add su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti. La dimensione di tutte le sottoliste e della lista principale deve aumentare di 1.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento della funzione add di cui si e' fatto l'override nella classe SubList. La dimensione
 deve essere aggiornata coerentemente in modo ricorsivo.</dd>
<dt>Pre-Condition:</dt>
<dd>create liste e sottoliste valide</dd>
<dt>Post-Condition:</dt>
<dd>l'elemento e' stato inserito in tutte le sottoliste.</dd>
<dt>Test Description:</dt>
<dd>Si creano delle sottoliste e si inserisce un elemento alla fine dell'ultima delle sottoliste create.<pre>
 list:                 ===>       sub:          ===>       sub1:       ===>    sub2:
 | 0 | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 |             | 1 | 2 |           | 2 |
</pre>
 Aggiungo un elemento "aggiunto" in coda a sub2. Le liste sono diventate:<pre>
 list:                       ===>          sub:                    ===>       sub1:                  ===>       sub2:
 | 0 | 1 | 2 | "aggiunto" | 3 | 4 |        | 1 | 2 | "aggiunto" | 3 |         | 1 | 2 | "aggiunto" |            | 2 | "aggiunto" |
</pre>
 La dimensione di tutte le sottoliste e' aumentata di 1. Si testa cio' invocando il metodo <code>size</code> su tutte le sottoliste.</dd>
<dt>Expected Results:</dt>
<dd>Tutte le sottoliste hanno aumentato la loro dimensione di 1 unita'</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddRecursiveSubListContains()">
<h3>testAddRecursiveSubListContains</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddRecursiveSubListContains</span>()</div>
<div class="block">Test del metodo <code>public boolean add(Object o)</code>: Testo che l'add su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti. L'elemento inserito deve essere presente in tutte le sottoliste e nella lista principale.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento della funzione add di cui si e' fatto l'override nella classe SubList. L'elemento
 deve essere correttamente inserito in modo ricorsivo.</dd>
<dt>Pre-Condition:</dt>
<dd>create liste e sottoliste valide</dd>
<dt>Post-Condition:</dt>
<dd>l'elemento e' stato inserito in tutte le sottoliste.</dd>
<dt>Test Description:</dt>
<dd>Si creano delle sottoliste e si inserisce un elemento alla fine dell'ultima delle sottoliste create.<pre>
 list:                 ===>       sub:          ===>       sub1:       ===>    sub2:
 | 0 | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 |             | 1 | 2 |           | 2 |
</pre>
 Aggiungo un elemento "aggiunto" in coda a sub2. Le liste sono diventate:<pre>
 list:                       ===>          sub:                    ===>       sub1:                  ===>       sub2:
 | 0 | 1 | 2 | "aggiunto" | 3 | 4 |        | 1 | 2 | "aggiunto" | 3 |         | 1 | 2 | "aggiunto" |            | 2 | "aggiunto" |
</pre>
 Si cerca l'elemento "aggiunto" con il metodo contains in tutte le liste</dd>
<dt>Expected Results:</dt>
<dd><code>contains("aggiunto")</code> deve ritornare <code>true</code> per tutte le sottoliste.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testAddRecursiveSubListGet()">
<h3>testAddRecursiveSubListGet</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testAddRecursiveSubListGet</span>()</div>
<div class="block">Test del metodo <code>public boolean add(Object o)</code>: Testo che l'add su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti. L'elemento inserito deve essere presente in tutte le sottoliste e nella lista principale nella posizione corretta.
 Faccio un controllo usando il get.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento della funzione add di cui si e' fatto l'override nella classe SubList. L'elemento
 deve essere correttamente inserito in modo ricorsivo usando l'indice corretto.</dd>
<dt>Pre-Condition:</dt>
<dd>create liste e sottoliste valide</dd>
<dt>Post-Condition:</dt>
<dd>l'elemento e' stato inserito in tutte le sottoliste.</dd>
<dt>Test Description:</dt>
<dd>Si creano delle sottoliste e si inserisce un elemento alla fine dell'ultima delle sottoliste create.<pre>
 list:                 ===>       sub:          ===>       sub1:       ===>    sub2:
 | 0 | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 |             | 2 | 3 |           | 2 |
</pre>
 Aggiungo un elemento "aggiunto" in cima a sub2. Le liste sono diventate:<pre>
 list:                       ===>          sub:                    ===>       sub1:                  ===>       sub2:
 | 0 | 1 | "aggiunto" | 2 | 3 | 4 |        | 1 | "aggiunto" | 2 | 3 |         | 1 | "aggiunto" | 2 |            | "aggiunto" | 2 |
</pre>
 Si cerca l'elemento "aggiunto" nella posizione aspettata in tutte le sottoliste.</dd>
<dt>Expected Results:</dt>
<dd><code>get(i)</code> deve ritornare <code>"aggiunto"</code> per tutte le sottoliste. Dove i e' stato creato
 in base al risultato aspettato.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveRecursiveSubListSize()">
<h3>testRemoveRecursiveSubListSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveRecursiveSubListSize</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: Testo che il remove su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti. La dimensione di tutte le sottoliste e della lista principale deve diminuire di 1.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento della funzione remmove di cui si e' fatto l'override nella classe SubList. La dimensione
 deve essere aggiornata coerentemente in modo ricorsivo.</dd>
<dt>Pre-Condition:</dt>
<dd>create liste e sottoliste valide</dd>
<dt>Post-Condition:</dt>
<dd>l'elemento e' stato rimosso da tutte le sottoliste.</dd>
<dt>Test Description:</dt>
<dd>Si creano delle sottoliste:<pre>
 list:                 ===>       sub:          ===>       sub1:       ===>    sub2:
 | 0 | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 |             | 1 | 2 |           | 2 |
</pre>
 Rimuovo l'elemento in testa a sub2 (il suo unico elemento). Le liste sono diventate:<pre>
 list:                       ===>          sub:                    ===>       sub1:                  ===>       sub2:
 | 0 | 1 | 3 | 4 |                         | 1 | 3 |                          | 1 |                             |
 </pre>
 La dimensione di tutte le sottoliste e' diminuita di 1. Si testa cio' invocando il metodo <code>size</code> su tutte le sottoliste.</dd>
<dt>Expected Results:</dt>
<dd>Tutte le sottoliste hanno diminuito la loro dimensione di 1 unita'</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="testRemoveRecursiveSubListContains()">
<h3>testRemoveRecursiveSubListContains</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="member-name">testRemoveRecursiveSubListContains</span>()</div>
<div class="block">Test del metodo <code>public boolean remove(Object o)</code>: Testo che il remove su una sottolista di sottolista si ripercuota
 su tutte le liste precedenti. L'elemento rimosso deve essere rimosso da tutte le sottoliste e dalla lista principale.</div>
<dl class="notes">
<dt>Test Case Design:</dt>
<dd>Accertamento del corretto comportamento della funzione remove di cui si e' fatto l'override nella classe SubList. L'elemento
 deve essere correttamente rimosso in modo ricorsivo.</dd>
<dt>Pre-Condition:</dt>
<dd>create liste e sottoliste valide</dd>
<dt>Post-Condition:</dt>
<dd>l'elemento e' stato rimosso in tutte le sottoliste.</dd>
<dt>Test Description:</dt>
<dd>Si creano delle sottoliste e si rimuove l'elemento dell'ultima sottolista creata.<pre>
 list:                 ===>       sub:          ===>       sub1:       ===>    sub2:
 | 0 | 1 | 2 | 3 | 4 |           | 1 | 2 | 3 |             | 1 | 2 |           | 2 |
 </pre>
 Rimuovo l'elemento in testa a sub2 (il suo unico elemento, ovvero 2). Le liste sono diventate:<pre>
 list:                       ===>          sub:                    ===>       sub1:                  ===>       sub2:
 | 0 | 1 | 3 | 4 |                         | 1 | 3 |                          | 1 |                             |
</pre>
 Si cerca l'elemento rimosso (2) con il metodo contains in tutte le liste.</dd>
<dt>Expected Results:</dt>
<dd><code>contains(2)</code> deve ritornare <code>false</code> per tutte le sottoliste.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
</footer>
</div>
</div>
</body>
</html>
